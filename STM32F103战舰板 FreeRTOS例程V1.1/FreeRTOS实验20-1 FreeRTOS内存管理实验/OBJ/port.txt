; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\obj\port.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\port.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\USER -I..\CORE -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\HARDWARE\LED -I..\HARDWARE\TIMER -I..\HARDWARE\LCD -I..\HARDWARE\EXTI -I..\HARDWARE\KEY -I..\HARDWARE\BEEP -I"E:\STM32F103战舰V3资料\STM32F103 FreeRTOS例程\FreeRTOS实验17-1 FreeRTOS内存管理实验\USER\RTE" -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\port.crf ..\FreeRTOS\portable\RVDS\ARM_CM3\port.c]
                          THUMB

                          AREA ||i.prvTaskExitError||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  prvTaskExitError PROC
;;;235    
;;;236    static void prvTaskExitError( void )
000000  4808              LDR      r0,|L1.36|
;;;237    {
;;;238    	/* A function that implements a task must not exit or attempt to return to
;;;239    	its caller as there is nothing to return to.  If a task wants to exit it
;;;240    	should instead call vTaskDelete( NULL ).
;;;241    
;;;242    	Artificially force an assert() to be triggered if configASSERT() is
;;;243    	defined, then stop here so application writers can catch the error. */
;;;244    	configASSERT( uxCriticalNesting == ~0UL );
000002  6840              LDR      r0,[r0,#4]  ; uxCriticalNesting
000004  1c40              ADDS     r0,r0,#1
000006  d004              BEQ      |L1.18|
000008  22f4              MOVS     r2,#0xf4
00000a  a107              ADR      r1,|L1.40|
00000c  a011              ADR      r0,|L1.84|
00000e  f7fffffe          BL       __2printf
                  |L1.18|
000012  2050              MOVS     r0,#0x50
000014  f3808811          MSR      BASEPRI,r0
000018  f3bf8f4f          DSB      
00001c  f3bf8f6f          ISB      
                  |L1.32|
;;;245    	portDISABLE_INTERRUPTS();
;;;246    	for( ;; );
000020  e7fe              B        |L1.32|
;;;247    }
;;;248    /*-----------------------------------------------------------*/
                          ENDP

000022  0000              DCW      0x0000
                  |L1.36|
                          DCD      ||.data||
                  |L1.40|
000028  2e2e5c46          DCB      "..\\FreeRTOS\\portable\\RVDS\\ARM_CM3\\port.c",0
00002c  72656552
000030  544f535c
000034  706f7274
000038  61626c65
00003c  5c525644
000040  535c4152
000044  4d5f434d
000048  335c706f
00004c  72742e63
000050  00      
000051  00                DCB      0
000052  00                DCB      0
000053  00                DCB      0
                  |L1.84|
000054  4572726f          DCB      "Error:%s,%d\r\n",0
000058  723a2573
00005c  2c25640d
000060  0a00    
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.pxPortInitialiseStack||, CODE, READONLY, ALIGN=2

                  pxPortInitialiseStack PROC
;;;216     */
;;;217    StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
000000  b510              PUSH     {r4,lr}
;;;218    {
;;;219    	/* Simulate the stack frame as it would be created by a context switch
;;;220    	interrupt. */
;;;221    	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
000002  1f03              SUBS     r3,r0,#4
;;;222    	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
000004  f04f7480          MOV      r4,#0x1000000
;;;223    	pxTopOfStack--;
;;;224    	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
;;;225    	pxTopOfStack--;
;;;226    	*pxTopOfStack = ( StackType_t ) prvTaskExitError;	/* LR */
;;;227    
;;;228    	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
;;;229    	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
;;;230    	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
;;;231    
;;;232    	return pxTopOfStack;
000008  601c              STR      r4,[r3,#0]
00000a  1f1b              SUBS     r3,r3,#4
00000c  f0210101          BIC      r1,r1,#1              ;224
000010  6019              STR      r1,[r3,#0]
000012  1f19              SUBS     r1,r3,#4
000014  4b02              LDR      r3,|L2.32|
000016  600b              STR      r3,[r1,#0]
000018  3914              SUBS     r1,r1,#0x14
00001a  3840              SUBS     r0,r0,#0x40           ;229
00001c  600a              STR      r2,[r1,#0]            ;229
;;;233    }
00001e  bd10              POP      {r4,pc}
;;;234    /*-----------------------------------------------------------*/
                          ENDP

                  |L2.32|
                          DCD      prvTaskExitError

                          AREA ||i.vPortEndScheduler||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  vPortEndScheduler PROC
;;;357    
;;;358    void vPortEndScheduler( void )
000000  4805              LDR      r0,|L3.24|
;;;359    {
;;;360    	/* Not implemented in ports where there is nothing to return to.
;;;361    	Artificially force an assert. */
;;;362    	configASSERT( uxCriticalNesting == 1000UL );
000002  6840              LDR      r0,[r0,#4]  ; uxCriticalNesting
000004  f5b07f7a          CMP      r0,#0x3e8
000008  d005              BEQ      |L3.22|
00000a  f44f72b5          MOV      r2,#0x16a
00000e  a103              ADR      r1,|L3.28|
000010  a00d              ADR      r0,|L3.72|
000012  f7ffbffe          B.W      __2printf
                  |L3.22|
;;;363    }
000016  4770              BX       lr
;;;364    /*-----------------------------------------------------------*/
                          ENDP

                  |L3.24|
                          DCD      ||.data||
                  |L3.28|
00001c  2e2e5c46          DCB      "..\\FreeRTOS\\portable\\RVDS\\ARM_CM3\\port.c",0
000020  72656552
000024  544f535c
000028  706f7274
00002c  61626c65
000030  5c525644
000034  535c4152
000038  4d5f434d
00003c  335c706f
000040  72742e63
000044  00      
000045  00                DCB      0
000046  00                DCB      0
000047  00                DCB      0
                  |L3.72|
000048  4572726f          DCB      "Error:%s,%d\r\n",0
00004c  723a2573
000050  2c25640d
000054  0a00    
000056  00                DCB      0
000057  00                DCB      0

                          AREA ||i.vPortEnterCritical||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  vPortEnterCritical PROC
;;;365    
;;;366    void vPortEnterCritical( void )
000000  2050              MOVS     r0,#0x50
000002  f3808811          MSR      BASEPRI,r0
000006  f3bf8f4f          DSB      
00000a  f3bf8f6f          ISB      
;;;367    {
;;;368    	portDISABLE_INTERRUPTS();
;;;369    	uxCriticalNesting++;
00000e  4909              LDR      r1,|L4.52|
000010  6848              LDR      r0,[r1,#4]  ; uxCriticalNesting
000012  1c40              ADDS     r0,r0,#1
;;;370    
;;;371    	/* This is not the interrupt safe version of the enter critical function so
;;;372    	assert() if it is being called from an interrupt context.  Only API
;;;373    	functions that end in "FromISR" can be used in an interrupt.  Only assert if
;;;374    	the critical nesting count is 1 to protect against recursive calls if the
;;;375    	assert function also uses a critical section. */
;;;376    	if( uxCriticalNesting == 1 )
000014  6048              STR      r0,[r1,#4]  ; uxCriticalNesting
000016  2801              CMP      r0,#1
000018  d10a              BNE      |L4.48|
;;;377    	{
;;;378    		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
00001a  4807              LDR      r0,|L4.56|
00001c  6800              LDR      r0,[r0,#0]
00001e  f0100fff          TST      r0,#0xff
000022  d005              BEQ      |L4.48|
000024  f44f72bd          MOV      r2,#0x17a
000028  a104              ADR      r1,|L4.60|
00002a  a00f              ADR      r0,|L4.104|
00002c  f7ffbffe          B.W      __2printf
                  |L4.48|
;;;379    	}
;;;380    }
000030  4770              BX       lr
;;;381    /*-----------------------------------------------------------*/
                          ENDP

000032  0000              DCW      0x0000
                  |L4.52|
                          DCD      ||.data||
                  |L4.56|
                          DCD      0xe000ed04
                  |L4.60|
00003c  2e2e5c46          DCB      "..\\FreeRTOS\\portable\\RVDS\\ARM_CM3\\port.c",0
000040  72656552
000044  544f535c
000048  706f7274
00004c  61626c65
000050  5c525644
000054  535c4152
000058  4d5f434d
00005c  335c706f
000060  72742e63
000064  00      
000065  00                DCB      0
000066  00                DCB      0
000067  00                DCB      0
                  |L4.104|
000068  4572726f          DCB      "Error:%s,%d\r\n",0
00006c  723a2573
000070  2c25640d
000074  0a00    
000076  00                DCB      0
000077  00                DCB      0

                          AREA ||i.vPortExitCritical||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  vPortExitCritical PROC
;;;382    
;;;383    void vPortExitCritical( void )
000000  b510              PUSH     {r4,lr}
;;;384    {
;;;385    	configASSERT( uxCriticalNesting );
000002  4c08              LDR      r4,|L5.36|
000004  6860              LDR      r0,[r4,#4]            ;384  ; uxCriticalNesting
000006  b928              CBNZ     r0,|L5.20|
000008  f2401281          MOV      r2,#0x181
00000c  a106              ADR      r1,|L5.40|
00000e  a011              ADR      r0,|L5.84|
000010  f7fffffe          BL       __2printf
                  |L5.20|
;;;386    	uxCriticalNesting--;
000014  6860              LDR      r0,[r4,#4]  ; uxCriticalNesting
000016  1e40              SUBS     r0,r0,#1
;;;387    	if( uxCriticalNesting == 0 )
000018  6060              STR      r0,[r4,#4]  ; uxCriticalNesting
00001a  d101              BNE      |L5.32|
00001c  f3808811          MSR      BASEPRI,r0
                  |L5.32|
;;;388    	{
;;;389    		portENABLE_INTERRUPTS();
;;;390    	}
;;;391    }
000020  bd10              POP      {r4,pc}
;;;392    /*-----------------------------------------------------------*/
                          ENDP

000022  0000              DCW      0x0000
                  |L5.36|
                          DCD      ||.data||
                  |L5.40|
000028  2e2e5c46          DCB      "..\\FreeRTOS\\portable\\RVDS\\ARM_CM3\\port.c",0
00002c  72656552
000030  544f535c
000034  706f7274
000038  61626c65
00003c  5c525644
000040  535c4152
000044  4d5f434d
000048  335c706f
00004c  72742e63
000050  00      
000051  00                DCB      0
000052  00                DCB      0
000053  00                DCB      0
                  |L5.84|
000054  4572726f          DCB      "Error:%s,%d\r\n",0
000058  723a2573
00005c  2c25640d
000060  0a00    
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.vPortSetupTimerInterrupt||, CODE, READONLY, ALIGN=2

                  vPortSetupTimerInterrupt PROC
;;;612    
;;;613    	void vPortSetupTimerInterrupt( void )
000000  4806              LDR      r0,|L6.28|
;;;614    	{
;;;615    		/* Calculate the constants required to configure the tick interrupt. */
;;;616    		#if configUSE_TICKLESS_IDLE == 1
;;;617    		{
;;;618    			ulTimerCountsForOneTick = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ );
;;;619    			xMaximumPossibleSuppressedTicks = portMAX_24_BIT_NUMBER / ulTimerCountsForOneTick;
;;;620    			ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
;;;621    		}
;;;622    		#endif /* configUSE_TICKLESS_IDLE */
;;;623    
;;;624    		/* Configure SysTick to interrupt at the requested rate. */
;;;625    		portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
000002  f44f717a          MOV      r1,#0x3e8
000006  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000008  fbb0f1f1          UDIV     r1,r0,r1
00000c  f04f20e0          MOV      r0,#0xe000e000
000010  1e49              SUBS     r1,r1,#1
000012  6141              STR      r1,[r0,#0x14]
;;;626    		portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
000014  2107              MOVS     r1,#7
000016  6101              STR      r1,[r0,#0x10]
;;;627    	}
000018  4770              BX       lr
;;;628    
                          ENDP

00001a  0000              DCW      0x0000
                  |L6.28|
                          DCD      SystemCoreClock

                          AREA ||i.vPortValidateInterruptPriority||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  vPortValidateInterruptPriority PROC
;;;642    
;;;643    	void vPortValidateInterruptPriority( void )
000000  b510              PUSH     {r4,lr}
;;;644    	{
;;;645    	uint32_t ulCurrentInterrupt;
;;;646    	uint8_t ucCurrentPriority;
;;;647    
;;;648    		/* Obtain the number of the currently executing interrupt. */
;;;649    		ulCurrentInterrupt = vPortGetIPSR();
000002  f7fffffe          BL       vPortGetIPSR
;;;650    
;;;651    		/* Is the interrupt number a user defined interrupt? */
;;;652    		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
;;;653    		{
;;;654    			/* Look up the interrupt's priority. */
;;;655    			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
;;;656    
;;;657    			/* The following assertion will fail if a service routine (ISR) for
;;;658    			an interrupt that has been assigned a priority above
;;;659    			configMAX_SYSCALL_INTERRUPT_PRIORITY calls an ISR safe FreeRTOS API
;;;660    			function.  ISR safe FreeRTOS API functions must *only* be called
;;;661    			from interrupts that have been assigned a priority at or below
;;;662    			configMAX_SYSCALL_INTERRUPT_PRIORITY.
;;;663    
;;;664    			Numerically low interrupt priority numbers represent logically high
;;;665    			interrupt priorities, therefore the priority of the interrupt must
;;;666    			be set to a value equal to or numerically *higher* than
;;;667    			configMAX_SYSCALL_INTERRUPT_PRIORITY.
;;;668    
;;;669    			Interrupts that	use the FreeRTOS API must not be left at their
;;;670    			default priority of	zero as that is the highest possible priority,
;;;671    			which is guaranteed to be above configMAX_SYSCALL_INTERRUPT_PRIORITY,
;;;672    			and	therefore also guaranteed to be invalid.
;;;673    
;;;674    			FreeRTOS maintains separate thread and ISR API functions to ensure
;;;675    			interrupt entry is as fast and simple as possible.
;;;676    
;;;677    			The following links provide detailed information:
;;;678    			http://www.freertos.org/RTOS-Cortex-M3-M4.html
;;;679    			http://www.freertos.org/FAQHelp.html */
;;;680    			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
000006  4c10              LDR      r4,|L7.72|
000008  2810              CMP      r0,#0x10              ;652
00000a  d30c              BCC      |L7.38|
00000c  f10020e0          ADD      r0,r0,#0xe000e000     ;652
000010  f89003f0          LDRB     r0,[r0,#0x3f0]        ;655
000014  7821              LDRB     r1,[r4,#0]  ; ucMaxSysCallPriority
000016  4288              CMP      r0,r1
000018  d205              BCS      |L7.38|
00001a  f44f722a          MOV      r2,#0x2a8
00001e  a10b              ADR      r1,|L7.76|
000020  a015              ADR      r0,|L7.120|
000022  f7fffffe          BL       __2printf
                  |L7.38|
;;;681    		}
;;;682    
;;;683    		/* Priority grouping:  The interrupt controller (NVIC) allows the bits
;;;684    		that define each interrupt's priority to be split between bits that
;;;685    		define the interrupt's pre-emption priority bits and bits that define
;;;686    		the interrupt's sub-priority.  For simplicity all bits must be defined
;;;687    		to be pre-emption priority bits.  The following assertion will fail if
;;;688    		this is not the case (if some bits represent a sub-priority).
;;;689    
;;;690    		If the application only uses CMSIS libraries for interrupt
;;;691    		configuration then the correct setting can be achieved on all Cortex-M
;;;692    		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
;;;693    		scheduler.  Note however that some vendor specific peripheral libraries
;;;694    		assume a non-zero priority group setting, in which cases using a value
;;;695    		of zero will result in unpredicable behaviour. */
;;;696    		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
000026  4818              LDR      r0,|L7.136|
000028  6800              LDR      r0,[r0,#0]
00002a  68a1              LDR      r1,[r4,#8]  ; ulMaxPRIGROUPValue
00002c  f40060e0          AND      r0,r0,#0x700
000030  4288              CMP      r0,r1
000032  d907              BLS      |L7.68|
000034  e8bd4010          POP      {r4,lr}
000038  f44f722e          MOV      r2,#0x2b8
00003c  a103              ADR      r1,|L7.76|
00003e  a00e              ADR      r0,|L7.120|
000040  f7ffbffe          B.W      __2printf
                  |L7.68|
;;;697    	}
000044  bd10              POP      {r4,pc}
;;;698    
                          ENDP

000046  0000              DCW      0x0000
                  |L7.72|
                          DCD      ||.data||
                  |L7.76|
00004c  2e2e5c46          DCB      "..\\FreeRTOS\\portable\\RVDS\\ARM_CM3\\port.c",0
000050  72656552
000054  544f535c
000058  706f7274
00005c  61626c65
000060  5c525644
000064  535c4152
000068  4d5f434d
00006c  335c706f
000070  72742e63
000074  00      
000075  00                DCB      0
000076  00                DCB      0
000077  00                DCB      0
                  |L7.120|
000078  4572726f          DCB      "Error:%s,%d\r\n",0
00007c  723a2573
000080  2c25640d
000084  0a00    
000086  00                DCB      0
000087  00                DCB      0
                  |L7.136|
                          DCD      0xe000ed0c

                          AREA ||i.xPortStartScheduler||, CODE, READONLY, ALIGN=2

                  xPortStartScheduler PROC
;;;292     */
;;;293    BaseType_t xPortStartScheduler( void )
000000  b51c              PUSH     {r2-r4,lr}
;;;294    {
;;;295    	#if( configASSERT_DEFINED == 1 )
;;;296    	{
;;;297    		volatile uint32_t ulOriginalPriority;
;;;298    		volatile uint8_t * const pucFirstUserPriorityRegister = ( uint8_t * ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
000002  491a              LDR      r1,|L8.108|
;;;299    		volatile uint8_t ucMaxPriorityValue;
;;;300    
;;;301    		/* Determine the maximum priority from which ISR safe FreeRTOS API
;;;302    		functions can be called.  ISR safe functions are those that end in
;;;303    		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
;;;304    		ensure interrupt entry is as fast and simple as possible.
;;;305    
;;;306    		Save the interrupt priority value that is about to be clobbered. */
;;;307    		ulOriginalPriority = *pucFirstUserPriorityRegister;
000004  7808              LDRB     r0,[r1,#0]
;;;308    
;;;309    		/* Determine the number of priority bits available.  First write to all
;;;310    		possible bits. */
;;;311    		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
000006  9001              STR      r0,[sp,#4]
000008  20ff              MOVS     r0,#0xff
00000a  7008              STRB     r0,[r1,#0]
;;;312    
;;;313    		/* Read the value back to see how many bits stuck. */
;;;314    		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
00000c  7808              LDRB     r0,[r1,#0]
00000e  f88d0000          STRB     r0,[sp,#0]
;;;315    
;;;316    		/* Use the same mask on the maximum system call priority. */
;;;317    		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
000012  f89d0000          LDRB     r0,[sp,#0]
000016  4a16              LDR      r2,|L8.112|
000018  f0000050          AND      r0,r0,#0x50
00001c  7010              STRB     r0,[r2,#0]
;;;318    
;;;319    		/* Calculate the maximum acceptable priority group value for the number
;;;320    		of bits read back. */
;;;321    		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
00001e  2007              MOVS     r0,#7
000020  6090              STR      r0,[r2,#8]            ;294  ; ulMaxPRIGROUPValue
000022  e007              B        |L8.52|
                  |L8.36|
;;;322    		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
;;;323    		{
;;;324    			ulMaxPRIGROUPValue--;
000024  6890              LDR      r0,[r2,#8]  ; ulMaxPRIGROUPValue
000026  1e40              SUBS     r0,r0,#1
;;;325    			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
000028  6090              STR      r0,[r2,#8]  ; ulMaxPRIGROUPValue
00002a  f89d0000          LDRB     r0,[sp,#0]
00002e  0040              LSLS     r0,r0,#1
000030  f88d0000          STRB     r0,[sp,#0]
                  |L8.52|
000034  f89d0000          LDRB     r0,[sp,#0]            ;322
000038  0600              LSLS     r0,r0,#24             ;322
00003a  d4f3              BMI      |L8.36|
;;;326    		}
;;;327    
;;;328    		/* Shift the priority group value back to its position within the AIRCR
;;;329    		register. */
;;;330    		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
00003c  7a10              LDRB     r0,[r2,#8]  ; ulMaxPRIGROUPValue
00003e  0200              LSLS     r0,r0,#8
;;;331    		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
000040  f40060e0          AND      r0,r0,#0x700
;;;332    
;;;333    		/* Restore the clobbered interrupt priority register to its original
;;;334    		value. */
;;;335    		*pucFirstUserPriorityRegister = ulOriginalPriority;
000044  6090              STR      r0,[r2,#8]  ; ulMaxPRIGROUPValue
000046  9801              LDR      r0,[sp,#4]
000048  7008              STRB     r0,[r1,#0]
;;;336    	}
;;;337    	#endif /* conifgASSERT_DEFINED */
;;;338    
;;;339    	/* Make PendSV and SysTick the lowest priority interrupts. */
;;;340    	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
00004a  480a              LDR      r0,|L8.116|
00004c  6801              LDR      r1,[r0,#0]
00004e  f4410170          ORR      r1,r1,#0xf00000
000052  6001              STR      r1,[r0,#0]
;;;341    	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
000054  6801              LDR      r1,[r0,#0]
000056  f0414170          ORR      r1,r1,#0xf0000000
00005a  6001              STR      r1,[r0,#0]
;;;342    
;;;343    	/* Start the timer that generates the tick ISR.  Interrupts are disabled
;;;344    	here already. */
;;;345    	vPortSetupTimerInterrupt();
00005c  f7fffffe          BL       vPortSetupTimerInterrupt
;;;346    
;;;347    	/* Initialise the critical nesting count ready for the first task. */
;;;348    	uxCriticalNesting = 0;
000060  2000              MOVS     r0,#0
;;;349    
;;;350    	/* Start the first task. */
;;;351    	prvStartFirstTask();
000062  6050              STR      r0,[r2,#4]  ; uxCriticalNesting
000064  f7fffffe          BL       __asm___6_port_c_39a90d8d__prvStartFirstTask
;;;352    
;;;353    	/* Should not get here! */
;;;354    	return 0;
000068  2000              MOVS     r0,#0
;;;355    }
00006a  bd1c              POP      {r2-r4,pc}
;;;356    /*-----------------------------------------------------------*/
                          ENDP

                  |L8.108|
                          DCD      0xe000e400
                  |L8.112|
                          DCD      ||.data||
                  |L8.116|
                          DCD      0xe000ed20

                          AREA ||i.xPortSysTickHandler||, CODE, READONLY, ALIGN=2

                  xPortSysTickHandler PROC
;;;430    
;;;431    void xPortSysTickHandler( void )
000000  b510              PUSH     {r4,lr}
000002  2050              MOVS     r0,#0x50
000004  f3808811          MSR      BASEPRI,r0
000008  f3bf8f4f          DSB      
00000c  f3bf8f6f          ISB      
;;;432    {
;;;433    	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
;;;434    	executes all interrupts must be unmasked.  There is therefore no need to
;;;435    	save and then restore the interrupt mask value as its value is already
;;;436    	known - therefore the slightly faster vPortRaiseBASEPRI() function is used
;;;437    	in place of portSET_INTERRUPT_MASK_FROM_ISR(). */
;;;438    	vPortRaiseBASEPRI();
;;;439    	{
;;;440    		/* Increment the RTOS tick. */
;;;441    		if( xTaskIncrementTick() != pdFALSE )
000010  f7fffffe          BL       xTaskIncrementTick
000014  b118              CBZ      r0,|L9.30|
;;;442    		{
;;;443    			/* A context switch is required.  Context switching is performed in
;;;444    			the PendSV interrupt.  Pend the PendSV interrupt. */
;;;445    			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
000016  4904              LDR      r1,|L9.40|
000018  f04f5080          MOV      r0,#0x10000000
00001c  6008              STR      r0,[r1,#0]
                  |L9.30|
00001e  2000              MOVS     r0,#0
000020  f3808811          MSR      BASEPRI,r0
;;;446    		}
;;;447    	}
;;;448    	vPortClearBASEPRIFromISR();
;;;449    }
000024  bd10              POP      {r4,pc}
;;;450    /*-----------------------------------------------------------*/
                          ENDP

000026  0000              DCW      0x0000
                  |L9.40|
                          DCD      0xe000ed04

                          AREA ||.data||, DATA, ALIGN=2

                  ucMaxSysCallPriority
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  uxCriticalNesting
                          DCD      0xaaaaaaaa
                  ulMaxPRIGROUPValue
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\FreeRTOS\\portable\\RVDS\\ARM_CM3\\port.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |SVC_Handler|
#line 250
|SVC_Handler| PROC
#line 251

 PRESERVE8

 ldr r3, =pxCurrentTCB  
 ldr r1, [r3]  
 ldr r0, [r1]  
 ldmia r0!, {r4-r11}  
 msr psp, r0  
 isb
 mov r0, #0
 msr basepri, r0
 orr r14, #0xd
 bx r14
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___6_port_c_39a90d8d__prvStartFirstTask|
#line 267
|__asm___6_port_c_39a90d8d__prvStartFirstTask| PROC
#line 268

 PRESERVE8

 
 ldr r0, =0xE000ED08
 ldr r0, [r0]
 ldr r0, [r0]

 
 msr msp, r0
 
 cpsie i
 cpsie f
 dsb
 isb
 
 svc 0
 nop
 nop
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |PendSV_Handler|
#line 394
|PendSV_Handler| PROC
#line 395

 extern uxCriticalNesting
 extern pxCurrentTCB
 extern vTaskSwitchContext

 PRESERVE8

 mrs r0, psp
 isb

 ldr r3, =pxCurrentTCB  
 ldr r2, [r3]

 stmdb r0!, {r4-r11}  
 str r0, [r2]  

 stmdb sp!, {r3, r14}
 mov r0, #( 5 << (8 - 4) )
 msr basepri, r0
 dsb
 isb
 bl vTaskSwitchContext
 mov r0, #0
 msr basepri, r0
 ldmia sp!, {r3, r14}

 ldr r1, [r3]
 ldr r0, [r1]  
 ldmia r0!, {r4-r11}  
 msr psp, r0
 isb
 bx r14
 nop
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |vPortGetIPSR|
#line 632
|vPortGetIPSR| PROC
#line 633

 PRESERVE8

 mrs r0, ipsr
 bx r14
	ENDP

;*** End   embedded assembler ***
