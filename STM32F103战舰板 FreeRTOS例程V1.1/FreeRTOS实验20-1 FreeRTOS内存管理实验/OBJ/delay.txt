; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\obj\delay.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\delay.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\USER -I..\CORE -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\HARDWARE\LED -I..\HARDWARE\TIMER -I..\HARDWARE\LCD -I..\HARDWARE\EXTI -I..\HARDWARE\KEY -I..\HARDWARE\BEEP -I"E:\STM32F103战舰V3资料\STM32F103 FreeRTOS例程\FreeRTOS实验17-1 FreeRTOS内存管理实验\USER\RTE" -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\delay.crf ..\SYSTEM\delay\delay.c]
                          THUMB

                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=1

                  SysTick_Handler PROC
;;;31     //systick中断服务函数,使用ucos时用到
;;;32     void SysTick_Handler(void)
000000  b510              PUSH     {r4,lr}
;;;33     {	
;;;34         if(xTaskGetSchedulerState()!=taskSCHEDULER_NOT_STARTED)//系统已经运行
000002  f7fffffe          BL       xTaskGetSchedulerState
000006  2801              CMP      r0,#1
000008  d003              BEQ      |L1.18|
;;;35         {
;;;36             xPortSysTickHandler();	
00000a  e8bd4010          POP      {r4,lr}
00000e  f7ffbffe          B.W      xPortSysTickHandler
                  |L1.18|
;;;37         }
;;;38     }
000012  bd10              POP      {r4,pc}
;;;39     			   
                          ENDP


                          AREA ||i.delay_init||, CODE, READONLY, ALIGN=2

                  delay_init PROC
;;;43     //SYSCLK:系统时钟频率
;;;44     void delay_init()
000000  b510              PUSH     {r4,lr}
;;;45     {
;;;46     	u32 reload;
;;;47     	SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK);//选择外部时钟  HCLK
000002  2004              MOVS     r0,#4
000004  f7fffffe          BL       SysTick_CLKSourceConfig
;;;48     	fac_us=SystemCoreClock/1000000;				//不论是否使用OS,fac_us都需要使用
000008  480c              LDR      r0,|L2.60|
00000a  490d              LDR      r1,|L2.64|
00000c  4a0d              LDR      r2,|L2.68|
00000e  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000010  fbb0f3f1          UDIV     r3,r0,r1
;;;49     	reload=SystemCoreClock/1000000;				//每秒钟的计数次数 单位为M  
000014  fbb0f1f1          UDIV     r1,r0,r1
;;;50     	reload*=1000000/configTICK_RATE_HZ;			//根据configTICK_RATE_HZ设定溢出时间
000018  f44f707a          MOV      r0,#0x3e8
00001c  4341              MULS     r1,r0,r1
00001e  7013              STRB     r3,[r2,#0]            ;48
;;;51     												//reload为24位寄存器,最大值:16777216,在72M下,约合0.233s左右	
;;;52     	fac_ms=1000/configTICK_RATE_HZ;				//代表OS可以延时的最少单位	   
000020  2001              MOVS     r0,#1
000022  8050              STRH     r0,[r2,#2]
;;;53     
;;;54     	SysTick->CTRL|=SysTick_CTRL_TICKINT_Msk;   	//开启SYSTICK中断
000024  f04f20e0          MOV      r0,#0xe000e000
000028  6902              LDR      r2,[r0,#0x10]
00002a  f0420202          ORR      r2,r2,#2
00002e  6102              STR      r2,[r0,#0x10]
;;;55     	SysTick->LOAD=reload; 						//每1/configTICK_RATE_HZ秒中断一次	
000030  6141              STR      r1,[r0,#0x14]
;;;56     	SysTick->CTRL|=SysTick_CTRL_ENABLE_Msk;   	//开启SYSTICK    
000032  6901              LDR      r1,[r0,#0x10]
000034  f0410101          ORR      r1,r1,#1
000038  6101              STR      r1,[r0,#0x10]
;;;57     }								    
00003a  bd10              POP      {r4,pc}
;;;58     
                          ENDP

                  |L2.60|
                          DCD      SystemCoreClock
                  |L2.64|
                          DCD      0x000f4240
                  |L2.68|
                          DCD      ||.data||

                          AREA ||i.delay_ms||, CODE, READONLY, ALIGN=2

                  delay_ms PROC
;;;84     //nms:0~65535
;;;85     void delay_ms(u32 nms)
000000  b570              PUSH     {r4-r6,lr}
;;;86     {	
000002  4604              MOV      r4,r0
;;;87     	if(xTaskGetSchedulerState()!=taskSCHEDULER_NOT_STARTED)//系统已经运行
000004  f7fffffe          BL       xTaskGetSchedulerState
000008  2801              CMP      r0,#1
00000a  d00c              BEQ      |L3.38|
;;;88     	{		
;;;89     		if(nms>=fac_ms)						//延时的时间大于OS的最少时间周期 
00000c  4d09              LDR      r5,|L3.52|
00000e  8868              LDRH     r0,[r5,#2]  ; fac_ms
000010  4284              CMP      r4,r0
000012  d303              BCC      |L3.28|
;;;90     		{ 
;;;91        			vTaskDelay(nms/fac_ms);	 		//FreeRTOS延时
000014  fbb4f0f0          UDIV     r0,r4,r0
000018  f7fffffe          BL       vTaskDelay
                  |L3.28|
;;;92     		}
;;;93     		nms%=fac_ms;						//OS已经无法提供这么小的延时了,采用普通方式延时    
00001c  8868              LDRH     r0,[r5,#2]  ; fac_ms
00001e  fbb4f1f0          UDIV     r1,r4,r0
000022  fb004411          MLS      r4,r0,r1,r4
                  |L3.38|
;;;94     	}
;;;95     	delay_us((u32)(nms*1000));				//普通方式延时
000026  f44f707a          MOV      r0,#0x3e8
00002a  4360              MULS     r0,r4,r0
00002c  e8bd4070          POP      {r4-r6,lr}
000030  f7ffbffe          B.W      delay_us
;;;96     }
;;;97     
                          ENDP

                  |L3.52|
                          DCD      ||.data||

                          AREA ||i.delay_us||, CODE, READONLY, ALIGN=2

                  delay_us PROC
;;;62     //nus:0~204522252(最大值即2^32/fac_us@fac_us=168)	    								   
;;;63     void delay_us(u32 nus)
000000  b570              PUSH     {r4-r6,lr}
;;;64     {		
;;;65     	u32 ticks;
;;;66     	u32 told,tnow,tcnt=0;
;;;67     	u32 reload=SysTick->LOAD;				//LOAD的值	    	 
000002  f04f25e0          MOV      r5,#0xe000e000
000006  2100              MOVS     r1,#0                 ;66
000008  696c              LDR      r4,[r5,#0x14]
;;;68     	ticks=nus*fac_us; 						//需要的节拍数 
00000a  4a09              LDR      r2,|L4.48|
;;;69     	told=SysTick->VAL;        				//刚进入时的计数器值
00000c  69ab              LDR      r3,[r5,#0x18]
00000e  7812              LDRB     r2,[r2,#0]            ;68  ; fac_us
000010  4350              MULS     r0,r2,r0              ;68
                  |L4.18|
;;;70     	while(1)
;;;71     	{
;;;72     		tnow=SysTick->VAL;	
000012  69aa              LDR      r2,[r5,#0x18]
;;;73     		if(tnow!=told)
000014  429a              CMP      r2,r3
000016  d0fc              BEQ      |L4.18|
;;;74     		{	    
;;;75     			if(tnow<told)tcnt+=told-tnow;	//这里注意一下SYSTICK是一个递减的计数器就可以了.
000018  d202              BCS      |L4.32|
00001a  eba30302          SUB      r3,r3,r2
00001e  e002              B        |L4.38|
                  |L4.32|
;;;76     			else tcnt+=reload-tnow+told;	    
000020  eba40602          SUB      r6,r4,r2
000024  4433              ADD      r3,r3,r6
                  |L4.38|
000026  4419              ADD      r1,r1,r3
;;;77     			told=tnow;
000028  4613              MOV      r3,r2
;;;78     			if(tcnt>=ticks)break;			//时间超过/等于要延迟的时间,则退出.
00002a  4281              CMP      r1,r0
00002c  d3f1              BCC      |L4.18|
;;;79     		}  
;;;80     	};										    
;;;81     }  
00002e  bd70              POP      {r4-r6,pc}
;;;82     //延时nms
                          ENDP

                  |L4.48|
                          DCD      ||.data||

                          AREA ||i.delay_xms||, CODE, READONLY, ALIGN=1

                  delay_xms PROC
;;;99     //nms:要延时的ms数
;;;100    void delay_xms(u32 nms)
000000  b570              PUSH     {r4-r6,lr}
;;;101    {
000002  4605              MOV      r5,r0
;;;102    	u32 i;
;;;103    	for(i=0;i<nms;i++) delay_us(1000);
000004  2400              MOVS     r4,#0
000006  f44f767a          MOV      r6,#0x3e8
00000a  e003              B        |L5.20|
                  |L5.12|
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       delay_us
000012  1c64              ADDS     r4,r4,#1
                  |L5.20|
000014  42ac              CMP      r4,r5
000016  d3f9              BCC      |L5.12|
;;;104    }
000018  bd70              POP      {r4-r6,pc}
;;;105    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=1

                  fac_us
000000  0000              DCB      0x00,0x00
                  fac_ms
000002  0000              DCW      0x0000
