; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\obj\event_groups.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\event_groups.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\USER -I..\CORE -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\HARDWARE\LED -I..\HARDWARE\TIMER -I..\HARDWARE\LCD -I..\HARDWARE\EXTI -I..\HARDWARE\KEY -I..\HARDWARE\BEEP -I"E:\STM32F103战舰V3资料\STM32F103 FreeRTOS例程\FreeRTOS实验17-1 FreeRTOS内存管理实验\USER\RTE" -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\event_groups.crf ..\FreeRTOS\event_groups.c]
                          THUMB

                          AREA ||i.prvTestWaitCondition||, CODE, READONLY, ALIGN=1

                  prvTestWaitCondition PROC
;;;681    
;;;682    static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
000000  4603              MOV      r3,r0
;;;683    {
;;;684    BaseType_t xWaitConditionMet = pdFALSE;
000002  2000              MOVS     r0,#0
000004  b112              CBZ      r2,|L1.12|
;;;685    
;;;686    	if( xWaitForAllBits == pdFALSE )
;;;687    	{
;;;688    		/* Task only has to wait for one bit within uxBitsToWaitFor to be
;;;689    		set.  Is one already set? */
;;;690    		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
;;;691    		{
;;;692    			xWaitConditionMet = pdTRUE;
;;;693    		}
;;;694    		else
;;;695    		{
;;;696    			mtCOVERAGE_TEST_MARKER();
;;;697    		}
;;;698    	}
;;;699    	else
;;;700    	{
;;;701    		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
;;;702    		Are they set already? */
;;;703    		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
000006  4399              BICS     r1,r1,r3
000008  d002              BEQ      |L1.16|
                  |L1.10|
;;;704    		{
;;;705    			xWaitConditionMet = pdTRUE;
;;;706    		}
;;;707    		else
;;;708    		{
;;;709    			mtCOVERAGE_TEST_MARKER();
;;;710    		}
;;;711    	}
;;;712    
;;;713    	return xWaitConditionMet;
;;;714    }
00000a  4770              BX       lr
                  |L1.12|
00000c  420b              TST      r3,r1                 ;690
00000e  d0fc              BEQ      |L1.10|
                  |L1.16|
000010  2001              MOVS     r0,#1                 ;692
000012  4770              BX       lr
;;;715    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxEventGroupGetNumber||, CODE, READONLY, ALIGN=1

                  uxEventGroupGetNumber PROC
;;;733    
;;;734    	UBaseType_t uxEventGroupGetNumber( void* xEventGroup )
000000  2800              CMP      r0,#0
;;;735    	{
000002  d000              BEQ      |L2.6|
;;;736    	UBaseType_t xReturn;
;;;737    	EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
;;;738    
;;;739    		if( xEventGroup == NULL )
;;;740    		{
;;;741    			xReturn = 0;
;;;742    		}
;;;743    		else
;;;744    		{
;;;745    			xReturn = pxEventBits->uxEventGroupNumber;
000004  6980              LDR      r0,[r0,#0x18]
                  |L2.6|
;;;746    		}
;;;747    
;;;748    		return xReturn;
;;;749    	}
000006  4770              BX       lr
;;;750    
                          ENDP


                          AREA ||i.vEventGroupClearBitsCallback||, CODE, READONLY, ALIGN=1

                  vEventGroupClearBitsCallback PROC
;;;675    an interrupt. */
;;;676    void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
000000  f7ffbffe          B.W      xEventGroupClearBits
;;;677    {
;;;678    	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
;;;679    }
;;;680    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vEventGroupDelete||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                  vEventGroupDelete PROC
;;;623    
;;;624    void vEventGroupDelete( EventGroupHandle_t xEventGroup )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;625    {
000004  4606              MOV      r6,r0
;;;626    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
;;;627    const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
000006  1d04              ADDS     r4,r0,#4
;;;628    
;;;629    	vTaskSuspendAll();
000008  f7fffffe          BL       vTaskSuspendAll
;;;630    	{
;;;631    		traceEVENT_GROUP_DELETE( xEventGroup );
;;;632    
;;;633    		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
;;;634    		{
;;;635    			/* Unblock the task, returning 0 as the event list is being deleted
;;;636    			and	cannot therefore have any bits set. */
;;;637    			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
00000c  f1040508          ADD      r5,r4,#8
000010  f240277d          MOV      r7,#0x27d
;;;638    			( void ) xTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
000014  f04f7800          MOV      r8,#0x2000000
000018  e00b              B        |L4.50|
                  |L4.26|
00001a  68e0              LDR      r0,[r4,#0xc]          ;637
00001c  42a8              CMP      r0,r5                 ;637
00001e  d104              BNE      |L4.42|
000020  463a              MOV      r2,r7                 ;637
000022  a109              ADR      r1,|L4.72|
000024  a00f              ADR      r0,|L4.100|
000026  f7fffffe          BL       __2printf
                  |L4.42|
00002a  4641              MOV      r1,r8
00002c  68e0              LDR      r0,[r4,#0xc]
00002e  f7fffffe          BL       xTaskRemoveFromUnorderedEventList
                  |L4.50|
000032  6820              LDR      r0,[r4,#0]            ;633
000034  2800              CMP      r0,#0                 ;633
000036  d1f0              BNE      |L4.26|
;;;639    		}
;;;640    
;;;641    		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
;;;642    		{
;;;643    			/* The event group can only have been allocated dynamically - free
;;;644    			it again. */
;;;645    			vPortFree( pxEventBits );
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       vPortFree
;;;646    		}
;;;647    		#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
;;;648    		{
;;;649    			/* The event group could have been allocated statically or
;;;650    			dynamically, so check before attempting to free the memory. */
;;;651    			if( pxEventBits->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
;;;652    			{
;;;653    				vPortFree( pxEventBits );
;;;654    			}
;;;655    			else
;;;656    			{
;;;657    				mtCOVERAGE_TEST_MARKER();
;;;658    			}
;;;659    		}
;;;660    		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;661    	}
;;;662    	( void ) xTaskResumeAll();
00003e  e8bd41f0          POP      {r4-r8,lr}
000042  f7ffbffe          B.W      xTaskResumeAll
;;;663    }
;;;664    /*-----------------------------------------------------------*/
                          ENDP

000046  0000              DCW      0x0000
                  |L4.72|
000048  2e2e5c46          DCB      "..\\FreeRTOS\\event_groups.c",0
00004c  72656552
000050  544f535c
000054  6576656e
000058  745f6772
00005c  6f757073
000060  2e6300  
000063  00                DCB      0
                  |L4.100|
000064  4572726f          DCB      "Error:%s,%d\r\n",0
000068  723a2573
00006c  2c25640d
000070  0a00    
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.vEventGroupSetBitsCallback||, CODE, READONLY, ALIGN=1

                  vEventGroupSetBitsCallback PROC
;;;667    an interrupt. */
;;;668    void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
000000  f7ffbffe          B.W      xEventGroupSetBits
;;;669    {
;;;670    	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
;;;671    }
;;;672    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xEventGroupClearBits||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  xEventGroupClearBits PROC
;;;471    
;;;472    EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
000000  b570              PUSH     {r4-r6,lr}
;;;473    {
000002  460e              MOV      r6,r1
;;;474    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
000004  0004              MOVS     r4,r0
000006  d105              BNE      |L6.20|
;;;475    EventBits_t uxReturn;
;;;476    
;;;477    	/* Check the user is not attempting to clear the bits used by the kernel
;;;478    	itself. */
;;;479    	configASSERT( xEventGroup );
000008  f24012df          MOV      r2,#0x1df
00000c  a10a              ADR      r1,|L6.56|
00000e  a011              ADR      r0,|L6.84|
000010  f7fffffe          BL       __2printf
                  |L6.20|
;;;480    	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
000014  0e30              LSRS     r0,r6,#24
000016  d005              BEQ      |L6.36|
000018  f44f72f0          MOV      r2,#0x1e0
00001c  a106              ADR      r1,|L6.56|
00001e  a00d              ADR      r0,|L6.84|
000020  f7fffffe          BL       __2printf
                  |L6.36|
;;;481    
;;;482    	taskENTER_CRITICAL();
000024  f7fffffe          BL       vPortEnterCritical
;;;483    	{
;;;484    		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );
;;;485    
;;;486    		/* The value returned is the event group value prior to the bits being
;;;487    		cleared. */
;;;488    		uxReturn = pxEventBits->uxEventBits;
;;;489    
;;;490    		/* Clear the bits. */
;;;491    		pxEventBits->uxEventBits &= ~uxBitsToClear;
000028  6825              LDR      r5,[r4,#0]
00002a  ea250006          BIC      r0,r5,r6
;;;492    	}
;;;493    	taskEXIT_CRITICAL();
00002e  6020              STR      r0,[r4,#0]
000030  f7fffffe          BL       vPortExitCritical
;;;494    
;;;495    	return uxReturn;
000034  4628              MOV      r0,r5
;;;496    }
000036  bd70              POP      {r4-r6,pc}
;;;497    /*-----------------------------------------------------------*/
                          ENDP

                  |L6.56|
000038  2e2e5c46          DCB      "..\\FreeRTOS\\event_groups.c",0
00003c  72656552
000040  544f535c
000044  6576656e
000048  745f6772
00004c  6f757073
000050  2e6300  
000053  00                DCB      0
                  |L6.84|
000054  4572726f          DCB      "Error:%s,%d\r\n",0
000058  723a2573
00005c  2c25640d
000060  0a00    
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.xEventGroupClearBitsFromISR||, CODE, READONLY, ALIGN=2

                  xEventGroupClearBitsFromISR PROC
;;;500    
;;;501    	BaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
000000  460a              MOV      r2,r1
;;;502    	{
;;;503    		BaseType_t xReturn;
;;;504    
;;;505    		traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear );
;;;506    		xReturn = xTimerPendFunctionCallFromISR( vEventGroupClearBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToClear, NULL );
000002  4601              MOV      r1,r0
000004  2300              MOVS     r3,#0
000006  4801              LDR      r0,|L7.12|
000008  f7ffbffe          B.W      xTimerPendFunctionCallFromISR
;;;507    
;;;508    		return xReturn;
;;;509    	}
;;;510    
                          ENDP

                  |L7.12|
                          DCD      vEventGroupClearBitsCallback

                          AREA ||i.xEventGroupCreate||, CODE, READONLY, ALIGN=1

                  xEventGroupCreate PROC
;;;173    
;;;174    	EventGroupHandle_t xEventGroupCreate( void )
000000  b510              PUSH     {r4,lr}
;;;175    	{
;;;176    	EventGroup_t *pxEventBits;
;;;177    
;;;178    		/* Allocate the event group. */
;;;179    		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
000002  201c              MOVS     r0,#0x1c
000004  f7fffffe          BL       pvPortMalloc
000008  0004              MOVS     r4,r0
;;;180    
;;;181    		if( pxEventBits != NULL )
00000a  d004              BEQ      |L8.22|
;;;182    		{
;;;183    			pxEventBits->uxEventBits = 0;
00000c  2000              MOVS     r0,#0
;;;184    			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
00000e  6020              STR      r0,[r4,#0]
000010  1d20              ADDS     r0,r4,#4
000012  f7fffffe          BL       vListInitialise
                  |L8.22|
;;;185    
;;;186    			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;187    			{
;;;188    				/* Both static and dynamic allocation can be used, so note this
;;;189    				event group was allocated statically in case the event group is
;;;190    				later deleted. */
;;;191    				pxEventBits->ucStaticallyAllocated = pdFALSE;
;;;192    			}
;;;193    			#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;194    
;;;195    			traceEVENT_GROUP_CREATE( pxEventBits );
;;;196    		}
;;;197    		else
;;;198    		{
;;;199    			traceEVENT_GROUP_CREATE_FAILED();
;;;200    		}
;;;201    
;;;202    		return ( EventGroupHandle_t ) pxEventBits;
000016  4620              MOV      r0,r4
;;;203    	}
000018  bd10              POP      {r4,pc}
;;;204    
                          ENDP


                          AREA ||i.xEventGroupGetBitsFromISR||, CODE, READONLY, ALIGN=1

                  xEventGroupGetBitsFromISR PROC
;;;513    
;;;514    EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
000000  2250              MOVS     r2,#0x50
000002  f3ef8111          MRS      r1,BASEPRI
000006  f3828811          MSR      BASEPRI,r2
00000a  f3bf8f4f          DSB      
00000e  f3bf8f6f          ISB      
;;;515    {
;;;516    UBaseType_t uxSavedInterruptStatus;
;;;517    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
;;;518    EventBits_t uxReturn;
;;;519    
;;;520    	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
;;;521    	{
;;;522    		uxReturn = pxEventBits->uxEventBits;
000012  6800              LDR      r0,[r0,#0]
000014  f3818811          MSR      BASEPRI,r1
;;;523    	}
;;;524    	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;525    
;;;526    	return uxReturn;
;;;527    }
000018  4770              BX       lr
;;;528    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xEventGroupSetBits||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  xEventGroupSetBits PROC
;;;529    
;;;530    EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;531    {
;;;532    ListItem_t *pxListItem, *pxNext;
;;;533    ListItem_t const *pxListEnd;
;;;534    List_t *pxList;
;;;535    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
000004  2500              MOVS     r5,#0
000006  4688              MOV      r8,r1                 ;531
;;;536    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
000008  0004              MOVS     r4,r0
00000a  d105              BNE      |L10.24|
;;;537    BaseType_t xMatchFound = pdFALSE;
;;;538    
;;;539    	/* Check the user is not attempting to set the bits used by the kernel
;;;540    	itself. */
;;;541    	configASSERT( xEventGroup );
00000c  f240221d          MOV      r2,#0x21d
000010  a11c              ADR      r1,|L10.132|
000012  a023              ADR      r0,|L10.160|
000014  f7fffffe          BL       __2printf
                  |L10.24|
;;;542    	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
000018  ea5f6018          LSRS     r0,r8,#24
00001c  d005              BEQ      |L10.42|
00001e  f240221e          MOV      r2,#0x21e
000022  a118              ADR      r1,|L10.132|
000024  a01e              ADR      r0,|L10.160|
000026  f7fffffe          BL       __2printf
                  |L10.42|
;;;543    
;;;544    	pxList = &( pxEventBits->xTasksWaitingForBits );
00002a  1d26              ADDS     r6,r4,#4
;;;545    	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
00002c  f104070c          ADD      r7,r4,#0xc
;;;546    	vTaskSuspendAll();
000030  f7fffffe          BL       vTaskSuspendAll
;;;547    	{
;;;548    		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );
;;;549    
;;;550    		pxListItem = listGET_HEAD_ENTRY( pxList );
;;;551    
;;;552    		/* Set the bits. */
;;;553    		pxEventBits->uxEventBits |= uxBitsToSet;
000034  6821              LDR      r1,[r4,#0]
000036  68f0              LDR      r0,[r6,#0xc]
000038  ea410108          ORR      r1,r1,r8
;;;554    
;;;555    		/* See if the new bit value should unblock any tasks. */
;;;556    		while( pxListItem != pxListEnd )
00003c  6021              STR      r1,[r4,#0]
00003e  e017              B        |L10.112|
                  |L10.64|
000040  e9d01600          LDRD     r1,r6,[r0,#0]
;;;557    		{
;;;558    			pxNext = listGET_NEXT( pxListItem );
;;;559    			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
;;;560    			xMatchFound = pdFALSE;
;;;561    
;;;562    			/* Split the bits waited for from the control bits. */
;;;563    			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
000044  f001427f          AND      r2,r1,#0xff000000
;;;564    			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
;;;565    
;;;566    			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
000048  0153              LSLS     r3,r2,#5
00004a  6823              LDR      r3,[r4,#0]
00004c  f021417f          BIC      r1,r1,#0xff000000     ;564
000050  d402              BMI      |L10.88|
;;;567    			{
;;;568    				/* Just looking for single bit being set. */
;;;569    				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
000052  420b              TST      r3,r1
000054  d103              BNE      |L10.94|
000056  e00a              B        |L10.110|
                  |L10.88|
;;;570    				{
;;;571    					xMatchFound = pdTRUE;
;;;572    				}
;;;573    				else
;;;574    				{
;;;575    					mtCOVERAGE_TEST_MARKER();
;;;576    				}
;;;577    			}
;;;578    			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
000058  ea310303          BICS     r3,r1,r3
00005c  d107              BNE      |L10.110|
                  |L10.94|
;;;579    			{
;;;580    				/* All bits are set. */
;;;581    				xMatchFound = pdTRUE;
;;;582    			}
;;;583    			else
;;;584    			{
;;;585    				/* Need all bits to be set, but not all the bits were set. */
;;;586    			}
;;;587    
;;;588    			if( xMatchFound != pdFALSE )
;;;589    			{
;;;590    				/* The bits match.  Should the bits be cleared on exit? */
;;;591    				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
00005e  01d2              LSLS     r2,r2,#7
000060  d500              BPL      |L10.100|
;;;592    				{
;;;593    					uxBitsToClear |= uxBitsWaitedFor;
000062  430d              ORRS     r5,r5,r1
                  |L10.100|
;;;594    				}
;;;595    				else
;;;596    				{
;;;597    					mtCOVERAGE_TEST_MARKER();
;;;598    				}
;;;599    
;;;600    				/* Store the actual event flag value in the task's event list
;;;601    				item before removing the task from the event list.  The
;;;602    				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
;;;603    				that is was unblocked due to its required bits matching, rather
;;;604    				than because it timed out. */
;;;605    				( void ) xTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
000064  6821              LDR      r1,[r4,#0]
000066  f0417100          ORR      r1,r1,#0x2000000
00006a  f7fffffe          BL       xTaskRemoveFromUnorderedEventList
                  |L10.110|
;;;606    			}
;;;607    
;;;608    			/* Move onto the next list item.  Note pxListItem->pxNext is not
;;;609    			used here as the list item may have been removed from the event list
;;;610    			and inserted into the ready/pending reading list. */
;;;611    			pxListItem = pxNext;
00006e  4630              MOV      r0,r6
                  |L10.112|
000070  42b8              CMP      r0,r7                 ;556
000072  d1e5              BNE      |L10.64|
;;;612    		}
;;;613    
;;;614    		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
;;;615    		bit was set in the control word. */
;;;616    		pxEventBits->uxEventBits &= ~uxBitsToClear;
000074  6820              LDR      r0,[r4,#0]
000076  43a8              BICS     r0,r0,r5
;;;617    	}
;;;618    	( void ) xTaskResumeAll();
000078  6020              STR      r0,[r4,#0]
00007a  f7fffffe          BL       xTaskResumeAll
;;;619    
;;;620    	return pxEventBits->uxEventBits;
00007e  6820              LDR      r0,[r4,#0]
;;;621    }
000080  e8bd81f0          POP      {r4-r8,pc}
;;;622    /*-----------------------------------------------------------*/
                          ENDP

                  |L10.132|
000084  2e2e5c46          DCB      "..\\FreeRTOS\\event_groups.c",0
000088  72656552
00008c  544f535c
000090  6576656e
000094  745f6772
000098  6f757073
00009c  2e6300  
00009f  00                DCB      0
                  |L10.160|
0000a0  4572726f          DCB      "Error:%s,%d\r\n",0
0000a4  723a2573
0000a8  2c25640d
0000ac  0a00    
0000ae  00                DCB      0
0000af  00                DCB      0

                          AREA ||i.xEventGroupSetBitsFromISR||, CODE, READONLY, ALIGN=2

                  xEventGroupSetBitsFromISR PROC
;;;718    
;;;719    	BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t *pxHigherPriorityTaskWoken )
000000  4613              MOV      r3,r2
;;;720    	{
;;;721    	BaseType_t xReturn;
;;;722    
;;;723    		traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet );
;;;724    		xReturn = xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken );
000002  460a              MOV      r2,r1
000004  4601              MOV      r1,r0
000006  4801              LDR      r0,|L11.12|
000008  f7ffbffe          B.W      xTimerPendFunctionCallFromISR
;;;725    
;;;726    		return xReturn;
;;;727    	}
;;;728    
                          ENDP

                  |L11.12|
                          DCD      vEventGroupSetBitsCallback

                          AREA ||i.xEventGroupSync||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  xEventGroupSync PROC
;;;207    
;;;208    EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;209    {
000004  4604              MOV      r4,r0
000006  461f              MOV      r7,r3
000008  4615              MOV      r5,r2
00000a  4688              MOV      r8,r1
;;;210    EventBits_t uxOriginalBitValue, uxReturn;
;;;211    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
;;;212    BaseType_t xAlreadyYielded;
;;;213    BaseType_t xTimeoutOccurred = pdFALSE;
;;;214    
;;;215    	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
00000c  0e10              LSRS     r0,r2,#24
00000e  d004              BEQ      |L12.26|
000010  22d7              MOVS     r2,#0xd7
000012  a127              ADR      r1,|L12.176|
000014  a02d              ADR      r0,|L12.204|
000016  f7fffffe          BL       __2printf
                  |L12.26|
;;;216    	configASSERT( uxBitsToWaitFor != 0 );
00001a  b925              CBNZ     r5,|L12.38|
00001c  22d8              MOVS     r2,#0xd8
00001e  a124              ADR      r1,|L12.176|
000020  a02a              ADR      r0,|L12.204|
000022  f7fffffe          BL       __2printf
                  |L12.38|
;;;217    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;218    	{
;;;219    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
000026  f7fffffe          BL       xTaskGetSchedulerState
00002a  b928              CBNZ     r0,|L12.56|
00002c  b127              CBZ      r7,|L12.56|
00002e  22db              MOVS     r2,#0xdb
000030  a11f              ADR      r1,|L12.176|
000032  a026              ADR      r0,|L12.204|
000034  f7fffffe          BL       __2printf
                  |L12.56|
;;;220    	}
;;;221    	#endif
;;;222    
;;;223    	vTaskSuspendAll();
000038  f7fffffe          BL       vTaskSuspendAll
;;;224    	{
;;;225    		uxOriginalBitValue = pxEventBits->uxEventBits;
00003c  4620              MOV      r0,r4
;;;226    
;;;227    		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
00003e  4641              MOV      r1,r8
000040  6826              LDR      r6,[r4,#0]
000042  f7fffffe          BL       xEventGroupSetBits
;;;228    
;;;229    		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
000046  ea460608          ORR      r6,r6,r8
00004a  ea350006          BICS     r0,r5,r6
00004e  d008              BEQ      |L12.98|
;;;230    		{
;;;231    			/* All the rendezvous bits are now set - no need to block. */
;;;232    			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
;;;233    
;;;234    			/* Rendezvous always clear the bits.  They will have been cleared
;;;235    			already unless this is the only task in the rendezvous. */
;;;236    			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
;;;237    
;;;238    			xTicksToWait = 0;
;;;239    		}
;;;240    		else
;;;241    		{
;;;242    			if( xTicksToWait != ( TickType_t ) 0 )
000050  b167              CBZ      r7,|L12.108|
;;;243    			{
;;;244    				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );
;;;245    
;;;246    				/* Store the bits that the calling task is waiting for in the
;;;247    				task's event list item so the kernel knows when a match is
;;;248    				found.  Then enter the blocked state. */
;;;249    				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
000052  f04561a0          ORR      r1,r5,#0x5000000
000056  463a              MOV      r2,r7
000058  1d20              ADDS     r0,r4,#4
00005a  f7fffffe          BL       vTaskPlaceOnUnorderedEventList
;;;250    
;;;251    				/* This assignment is obsolete as uxReturn will get set after
;;;252    				the task unblocks, but some compilers mistakenly generate a
;;;253    				warning about uxReturn being returned without being set if the
;;;254    				assignment is omitted. */
;;;255    				uxReturn = 0;
00005e  2600              MOVS     r6,#0
000060  e005              B        |L12.110|
                  |L12.98|
000062  6820              LDR      r0,[r4,#0]            ;236
000064  43a8              BICS     r0,r0,r5              ;236
000066  2700              MOVS     r7,#0                 ;238
000068  6020              STR      r0,[r4,#0]            ;238
00006a  e000              B        |L12.110|
                  |L12.108|
;;;256    			}
;;;257    			else
;;;258    			{
;;;259    				/* The rendezvous bits were not set, but no block time was
;;;260    				specified - just return the current event bit value. */
;;;261    				uxReturn = pxEventBits->uxEventBits;
00006c  6826              LDR      r6,[r4,#0]
                  |L12.110|
;;;262    			}
;;;263    		}
;;;264    	}
;;;265    	xAlreadyYielded = xTaskResumeAll();
00006e  f7fffffe          BL       xTaskResumeAll
;;;266    
;;;267    	if( xTicksToWait != ( TickType_t ) 0 )
000072  b1d7              CBZ      r7,|L12.170|
;;;268    	{
;;;269    		if( xAlreadyYielded == pdFALSE )
000074  b938              CBNZ     r0,|L12.134|
;;;270    		{
;;;271    			portYIELD_WITHIN_API();
000076  4919              LDR      r1,|L12.220|
000078  f04f5080          MOV      r0,#0x10000000
00007c  6008              STR      r0,[r1,#0]
00007e  f3bf8f4f          DSB      
000082  f3bf8f6f          ISB      
                  |L12.134|
;;;272    		}
;;;273    		else
;;;274    		{
;;;275    			mtCOVERAGE_TEST_MARKER();
;;;276    		}
;;;277    
;;;278    		/* The task blocked to wait for its required bits to be set - at this
;;;279    		point either the required bits were set or the block time expired.  If
;;;280    		the required bits were set they will have been stored in the task's
;;;281    		event list item, and they should now be retrieved then cleared. */
;;;282    		uxReturn = uxTaskResetEventItemValue();
000086  f7fffffe          BL       uxTaskResetEventItemValue
00008a  4606              MOV      r6,r0
;;;283    
;;;284    		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
00008c  0180              LSLS     r0,r0,#6
00008e  d40a              BMI      |L12.166|
;;;285    		{
;;;286    			/* The task timed out, just return the current event bit value. */
;;;287    			taskENTER_CRITICAL();
000090  f7fffffe          BL       vPortEnterCritical
;;;288    			{
;;;289    				uxReturn = pxEventBits->uxEventBits;
;;;290    
;;;291    				/* Although the task got here because it timed out before the
;;;292    				bits it was waiting for were set, it is possible that since it
;;;293    				unblocked another task has set the bits.  If this is the case
;;;294    				then it needs to clear the bits before exiting. */
;;;295    				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
000094  6826              LDR      r6,[r4,#0]
000096  ea350006          BICS     r0,r5,r6
00009a  d102              BNE      |L12.162|
;;;296    				{
;;;297    					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
00009c  ea260005          BIC      r0,r6,r5
0000a0  6020              STR      r0,[r4,#0]
                  |L12.162|
;;;298    				}
;;;299    				else
;;;300    				{
;;;301    					mtCOVERAGE_TEST_MARKER();
;;;302    				}
;;;303    			}
;;;304    			taskEXIT_CRITICAL();
0000a2  f7fffffe          BL       vPortExitCritical
                  |L12.166|
;;;305    
;;;306    			xTimeoutOccurred = pdTRUE;
;;;307    		}
;;;308    		else
;;;309    		{
;;;310    			/* The task unblocked because the bits were set. */
;;;311    		}
;;;312    
;;;313    		/* Control bits might be set as the task had blocked should not be
;;;314    		returned. */
;;;315    		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
0000a6  f026467f          BIC      r6,r6,#0xff000000
                  |L12.170|
;;;316    	}
;;;317    
;;;318    	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );
;;;319    
;;;320    	return uxReturn;
0000aa  4630              MOV      r0,r6
;;;321    }
0000ac  e8bd81f0          POP      {r4-r8,pc}
;;;322    /*-----------------------------------------------------------*/
                          ENDP

                  |L12.176|
0000b0  2e2e5c46          DCB      "..\\FreeRTOS\\event_groups.c",0
0000b4  72656552
0000b8  544f535c
0000bc  6576656e
0000c0  745f6772
0000c4  6f757073
0000c8  2e6300  
0000cb  00                DCB      0
                  |L12.204|
0000cc  4572726f          DCB      "Error:%s,%d\r\n",0
0000d0  723a2573
0000d4  2c25640d
0000d8  0a00    
0000da  00                DCB      0
0000db  00                DCB      0
                  |L12.220|
                          DCD      0xe000ed04

                          AREA ||i.xEventGroupWaitBits||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  xEventGroupWaitBits PROC
;;;323    
;;;324    EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;325    {
;;;326    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
000004  9f08              LDR      r7,[sp,#0x20]
000006  469a              MOV      r10,r3                ;325
000008  4691              MOV      r9,r2                 ;325
00000a  460d              MOV      r5,r1                 ;325
00000c  0004              MOVS     r4,r0
;;;327    EventBits_t uxReturn, uxControlBits = 0;
00000e  f04f0600          MOV      r6,#0
000012  d105              BNE      |L13.32|
;;;328    BaseType_t xWaitConditionMet, xAlreadyYielded;
;;;329    BaseType_t xTimeoutOccurred = pdFALSE;
;;;330    
;;;331    	/* Check the user is not attempting to wait on the bits used by the kernel
;;;332    	itself, and that at least one bit is being requested. */
;;;333    	configASSERT( xEventGroup );
000014  f240124d          MOV      r2,#0x14d
000018  a135              ADR      r1,|L13.240|
00001a  a03c              ADR      r0,|L13.268|
00001c  f7fffffe          BL       __2printf
                  |L13.32|
;;;334    	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
000020  0e28              LSRS     r0,r5,#24
000022  d005              BEQ      |L13.48|
000024  f44f72a7          MOV      r2,#0x14e
000028  a131              ADR      r1,|L13.240|
00002a  a038              ADR      r0,|L13.268|
00002c  f7fffffe          BL       __2printf
                  |L13.48|
;;;335    	configASSERT( uxBitsToWaitFor != 0 );
000030  b92d              CBNZ     r5,|L13.62|
000032  f240124f          MOV      r2,#0x14f
000036  a12e              ADR      r1,|L13.240|
000038  a034              ADR      r0,|L13.268|
00003a  f7fffffe          BL       __2printf
                  |L13.62|
;;;336    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;337    	{
;;;338    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
00003e  f7fffffe          BL       xTaskGetSchedulerState
000042  b930              CBNZ     r0,|L13.82|
000044  b12f              CBZ      r7,|L13.82|
000046  f44f72a9          MOV      r2,#0x152
00004a  a129              ADR      r1,|L13.240|
00004c  a02f              ADR      r0,|L13.268|
00004e  f7fffffe          BL       __2printf
                  |L13.82|
;;;339    	}
;;;340    	#endif
;;;341    
;;;342    	vTaskSuspendAll();
000052  f7fffffe          BL       vTaskSuspendAll
;;;343    	{
;;;344    		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
;;;345    
;;;346    		/* Check to see if the wait condition is already met or not. */
;;;347    		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
000056  f8d48000          LDR      r8,[r4,#0]
00005a  4652              MOV      r2,r10
00005c  4629              MOV      r1,r5
00005e  4640              MOV      r0,r8
000060  f7fffffe          BL       prvTestWaitCondition
;;;348    
;;;349    		if( xWaitConditionMet != pdFALSE )
000064  b140              CBZ      r0,|L13.120|
;;;350    		{
;;;351    			/* The wait condition has already been met so there is no need to
;;;352    			block. */
;;;353    			uxReturn = uxCurrentEventBits;
;;;354    			xTicksToWait = ( TickType_t ) 0;
000066  2700              MOVS     r7,#0
000068  4646              MOV      r6,r8                 ;353
;;;355    
;;;356    			/* Clear the wait bits if requested to do so. */
;;;357    			if( xClearOnExit != pdFALSE )
00006a  f1b90f00          CMP      r9,#0
00006e  d015              BEQ      |L13.156|
;;;358    			{
;;;359    				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
000070  6820              LDR      r0,[r4,#0]
000072  43a8              BICS     r0,r0,r5
000074  6020              STR      r0,[r4,#0]
000076  e011              B        |L13.156|
                  |L13.120|
;;;360    			}
;;;361    			else
;;;362    			{
;;;363    				mtCOVERAGE_TEST_MARKER();
;;;364    			}
;;;365    		}
;;;366    		else if( xTicksToWait == ( TickType_t ) 0 )
000078  b1af              CBZ      r7,|L13.166|
;;;367    		{
;;;368    			/* The wait condition has not been met, but no block time was
;;;369    			specified, so just return the current value. */
;;;370    			uxReturn = uxCurrentEventBits;
;;;371    		}
;;;372    		else
;;;373    		{
;;;374    			/* The task is going to block to wait for its required bits to be
;;;375    			set.  uxControlBits are used to remember the specified behaviour of
;;;376    			this call to xEventGroupWaitBits() - for use when the event bits
;;;377    			unblock the task. */
;;;378    			if( xClearOnExit != pdFALSE )
00007a  f1b90f00          CMP      r9,#0
00007e  d001              BEQ      |L13.132|
;;;379    			{
;;;380    				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
000080  f04f7680          MOV      r6,#0x1000000
                  |L13.132|
;;;381    			}
;;;382    			else
;;;383    			{
;;;384    				mtCOVERAGE_TEST_MARKER();
;;;385    			}
;;;386    
;;;387    			if( xWaitForAllBits != pdFALSE )
000084  f1ba0f00          CMP      r10,#0
000088  d001              BEQ      |L13.142|
;;;388    			{
;;;389    				uxControlBits |= eventWAIT_FOR_ALL_BITS;
00008a  f0466680          ORR      r6,r6,#0x4000000
                  |L13.142|
;;;390    			}
;;;391    			else
;;;392    			{
;;;393    				mtCOVERAGE_TEST_MARKER();
;;;394    			}
;;;395    
;;;396    			/* Store the bits that the calling task is waiting for in the
;;;397    			task's event list item so the kernel knows when a match is
;;;398    			found.  Then enter the blocked state. */
;;;399    			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
00008e  ea450106          ORR      r1,r5,r6
000092  463a              MOV      r2,r7
000094  1d20              ADDS     r0,r4,#4
000096  f7fffffe          BL       vTaskPlaceOnUnorderedEventList
;;;400    
;;;401    			/* This is obsolete as it will get set after the task unblocks, but
;;;402    			some compilers mistakenly generate a warning about the variable
;;;403    			being returned without being set if it is not done. */
;;;404    			uxReturn = 0;
00009a  2600              MOVS     r6,#0
                  |L13.156|
;;;405    
;;;406    			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
;;;407    		}
;;;408    	}
;;;409    	xAlreadyYielded = xTaskResumeAll();
00009c  f7fffffe          BL       xTaskResumeAll
;;;410    
;;;411    	if( xTicksToWait != ( TickType_t ) 0 )
0000a0  b31f              CBZ      r7,|L13.234|
;;;412    	{
;;;413    		if( xAlreadyYielded == pdFALSE )
0000a2  b110              CBZ      r0,|L13.170|
0000a4  e009              B        |L13.186|
                  |L13.166|
0000a6  4646              MOV      r6,r8                 ;370
0000a8  e7f8              B        |L13.156|
                  |L13.170|
;;;414    		{
;;;415    			portYIELD_WITHIN_API();
0000aa  491c              LDR      r1,|L13.284|
0000ac  f04f5080          MOV      r0,#0x10000000
0000b0  6008              STR      r0,[r1,#0]
0000b2  f3bf8f4f          DSB      
0000b6  f3bf8f6f          ISB      
                  |L13.186|
;;;416    		}
;;;417    		else
;;;418    		{
;;;419    			mtCOVERAGE_TEST_MARKER();
;;;420    		}
;;;421    
;;;422    		/* The task blocked to wait for its required bits to be set - at this
;;;423    		point either the required bits were set or the block time expired.  If
;;;424    		the required bits were set they will have been stored in the task's
;;;425    		event list item, and they should now be retrieved then cleared. */
;;;426    		uxReturn = uxTaskResetEventItemValue();
0000ba  f7fffffe          BL       uxTaskResetEventItemValue
0000be  4606              MOV      r6,r0
;;;427    
;;;428    		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
0000c0  0180              LSLS     r0,r0,#6
0000c2  d410              BMI      |L13.230|
;;;429    		{
;;;430    			taskENTER_CRITICAL();
0000c4  f7fffffe          BL       vPortEnterCritical
;;;431    			{
;;;432    				/* The task timed out, just return the current event bit value. */
;;;433    				uxReturn = pxEventBits->uxEventBits;
;;;434    
;;;435    				/* It is possible that the event bits were updated between this
;;;436    				task leaving the Blocked state and running again. */
;;;437    				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
0000c8  6826              LDR      r6,[r4,#0]
0000ca  4652              MOV      r2,r10
0000cc  4629              MOV      r1,r5
0000ce  4630              MOV      r0,r6
0000d0  f7fffffe          BL       prvTestWaitCondition
0000d4  b128              CBZ      r0,|L13.226|
;;;438    				{
;;;439    					if( xClearOnExit != pdFALSE )
0000d6  f1b90f00          CMP      r9,#0
0000da  d002              BEQ      |L13.226|
;;;440    					{
;;;441    						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
0000dc  6820              LDR      r0,[r4,#0]
0000de  43a8              BICS     r0,r0,r5
0000e0  6020              STR      r0,[r4,#0]
                  |L13.226|
;;;442    					}
;;;443    					else
;;;444    					{
;;;445    						mtCOVERAGE_TEST_MARKER();
;;;446    					}
;;;447    				}
;;;448    				else
;;;449    				{
;;;450    					mtCOVERAGE_TEST_MARKER();
;;;451    				}
;;;452    			}
;;;453    			taskEXIT_CRITICAL();
0000e2  f7fffffe          BL       vPortExitCritical
                  |L13.230|
;;;454    
;;;455    			/* Prevent compiler warnings when trace macros are not used. */
;;;456    			xTimeoutOccurred = pdFALSE;
;;;457    		}
;;;458    		else
;;;459    		{
;;;460    			/* The task unblocked because the bits were set. */
;;;461    		}
;;;462    
;;;463    		/* The task blocked so control bits may have been set. */
;;;464    		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
0000e6  f026467f          BIC      r6,r6,#0xff000000
                  |L13.234|
;;;465    	}
;;;466    	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );
;;;467    
;;;468    	return uxReturn;
0000ea  4630              MOV      r0,r6
;;;469    }
0000ec  e8bd87f0          POP      {r4-r10,pc}
;;;470    /*-----------------------------------------------------------*/
                          ENDP

                  |L13.240|
0000f0  2e2e5c46          DCB      "..\\FreeRTOS\\event_groups.c",0
0000f4  72656552
0000f8  544f535c
0000fc  6576656e
000100  745f6772
000104  6f757073
000108  2e6300  
00010b  00                DCB      0
                  |L13.268|
00010c  4572726f          DCB      "Error:%s,%d\r\n",0
000110  723a2573
000114  2c25640d
000118  0a00    
00011a  00                DCB      0
00011b  00                DCB      0
                  |L13.284|
                          DCD      0xe000ed04
