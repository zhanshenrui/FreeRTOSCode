; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\obj\malloc.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\malloc.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\USER -I..\CORE -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\HARDWARE\LED -I..\HARDWARE\TIMER -I..\HARDWARE\LCD -I..\HARDWARE\EXTI -I..\HARDWARE\KEY -I..\HARDWARE\BEEP -I"E:\STM32F103战舰V3资料\STM32F103 FreeRTOS例程\FreeRTOS实验17-1 FreeRTOS内存管理实验\USER\RTE" -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\malloc.crf ..\MALLOC\malloc.c]
                          THUMB

                          AREA ||i.my_mem_free||, CODE, READONLY, ALIGN=2

                  my_mem_free PROC
;;;110    //返回值:0,释放成功;1,释放失败;  
;;;111    u8 my_mem_free(u8 memx,u32 offset)  
000000  b570              PUSH     {r4-r6,lr}
;;;112    {  
;;;113        int i;  
;;;114        if(!mallco_dev.memrdy[memx])//未初始化,先执行初始化
000002  4a13              LDR      r2,|L1.80|
000004  1813              ADDS     r3,r2,r0
000006  7e1b              LDRB     r3,[r3,#0x18]
000008  b193              CBZ      r3,|L1.48|
;;;115    	{
;;;116    		mallco_dev.init(memx);    
;;;117            return 1;//未初始化  
;;;118        }  
;;;119        if(offset<memsize[memx])//偏移在内存池内. 
00000a  4b12              LDR      r3,|L1.84|
00000c  f8533020          LDR      r3,[r3,r0,LSL #2]
000010  428b              CMP      r3,r1
000012  d91a              BLS      |L1.74|
;;;120        {  
;;;121            int index=offset/memblksize[memx];			//偏移所在内存块号码  
000014  4b0f              LDR      r3,|L1.84|
;;;122            int nmemb=mallco_dev.memmap[memx][index];	//内存块数量
000016  eb020280          ADD      r2,r2,r0,LSL #2
00001a  3b08              SUBS     r3,r3,#8              ;121
00001c  f8533020          LDR      r3,[r3,r0,LSL #2]     ;121
000020  6910              LDR      r0,[r2,#0x10]
000022  fbb1f1f3          UDIV     r1,r1,r3              ;121
000026  f8304011          LDRH     r4,[r0,r1,LSL #1]
;;;123            for(i=0;i<nmemb;i++)  						//内存块清零
00002a  2000              MOVS     r0,#0
00002c  4603              MOV      r3,r0
00002e  e008              B        |L1.66|
                  |L1.48|
000030  6811              LDR      r1,[r2,#0]            ;116  ; mallco_dev
000032  4788              BLX      r1                    ;116
000034  2001              MOVS     r0,#1                 ;117
;;;124            {  
;;;125                mallco_dev.memmap[memx][index+i]=0;  
;;;126            }  
;;;127            return 0;  
;;;128        }else return 2;//偏移超区了.  
;;;129    }  
000036  bd70              POP      {r4-r6,pc}
                  |L1.56|
000038  6915              LDR      r5,[r2,#0x10]         ;125
00003a  180e              ADDS     r6,r1,r0              ;125
00003c  1c40              ADDS     r0,r0,#1              ;125
00003e  f8253016          STRH     r3,[r5,r6,LSL #1]     ;125
                  |L1.66|
000042  42a0              CMP      r0,r4                 ;123
000044  dbf8              BLT      |L1.56|
000046  2000              MOVS     r0,#0                 ;127
000048  bd70              POP      {r4-r6,pc}
                  |L1.74|
00004a  2002              MOVS     r0,#2                 ;128
00004c  bd70              POP      {r4-r6,pc}
;;;130    //释放内存(外部调用) 
                          ENDP

00004e  0000              DCW      0x0000
                  |L1.80|
                          DCD      ||.data||
                  |L1.84|
                          DCD      ||.constdata||+0x10

                          AREA ||i.my_mem_init||, CODE, READONLY, ALIGN=2

                  my_mem_init PROC
;;;58     //memx:所属内存块
;;;59     void my_mem_init(u8 memx)  
000000  b570              PUSH     {r4-r6,lr}
;;;60     {  
000002  4604              MOV      r4,r0
;;;61         mymemset(mallco_dev.memmap[memx], 0,memtblsize[memx]*2);//内存状态表数据清零  
000004  480b              LDR      r0,|L2.52|
000006  4e0c              LDR      r6,|L2.56|
000008  2100              MOVS     r1,#0
00000a  f8500024          LDR      r0,[r0,r4,LSL #2]
00000e  eb060584          ADD      r5,r6,r4,LSL #2
000012  0042              LSLS     r2,r0,#1
000014  6928              LDR      r0,[r5,#0x10]
000016  f7fffffe          BL       mymemset
;;;62     	mymemset(mallco_dev.membase[memx], 0,memsize[memx]);	//内存池所有数据清零  
00001a  4806              LDR      r0,|L2.52|
00001c  2100              MOVS     r1,#0
00001e  3010              ADDS     r0,r0,#0x10
000020  f8502024          LDR      r2,[r0,r4,LSL #2]
000024  68a8              LDR      r0,[r5,#8]
000026  f7fffffe          BL       mymemset
;;;63     	mallco_dev.memrdy[memx]=1;								//内存管理初始化OK  
00002a  2001              MOVS     r0,#1
00002c  1931              ADDS     r1,r6,r4
00002e  7608              STRB     r0,[r1,#0x18]
;;;64     }  
000030  bd70              POP      {r4-r6,pc}
;;;65     //获取内存使用率
                          ENDP

000032  0000              DCW      0x0000
                  |L2.52|
                          DCD      ||.constdata||
                  |L2.56|
                          DCD      ||.data||

                          AREA ||i.my_mem_malloc||, CODE, READONLY, ALIGN=2

                  my_mem_malloc PROC
;;;81     //返回值:0XFFFFFFFF,代表错误;其他,内存偏移地址 
;;;82     u32 my_mem_malloc(u8 memx,u32 size)  
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;83     {  
;;;84         signed long offset=0;  
;;;85         u32 nmemb;	//需要的内存块数  
;;;86     	u32 cmemb=0;//连续空内存块数
;;;87         u32 i;  
;;;88         if(!mallco_dev.memrdy[memx])mallco_dev.init(memx);//未初始化,先执行初始化 
000004  4e1f              LDR      r6,|L3.132|
000006  4605              MOV      r5,r0                 ;83
000008  2400              MOVS     r4,#0                 ;86
00000a  1970              ADDS     r0,r6,r5
00000c  460f              MOV      r7,r1                 ;83
00000e  7e00              LDRB     r0,[r0,#0x18]
000010  b910              CBNZ     r0,|L3.24|
000012  6831              LDR      r1,[r6,#0]  ; mallco_dev
000014  4628              MOV      r0,r5
000016  4788              BLX      r1
                  |L3.24|
;;;89         if(size==0)return 0XFFFFFFFF;//不需要分配
000018  f04f32ff          MOV      r2,#0xffffffff
00001c  b37f              CBZ      r7,|L3.126|
;;;90         nmemb=size/memblksize[memx];  	//获取需要分配的连续内存块数
00001e  4b1a              LDR      r3,|L3.136|
000020  f8531025          LDR      r1,[r3,r5,LSL #2]
000024  fbb7f0f1          UDIV     r0,r7,r1
;;;91         if(size%memblksize[memx])nmemb++;  
000028  fbb7fcf1          UDIV     r12,r7,r1
00002c  fb01711c          MLS      r1,r1,r12,r7
000030  b101              CBZ      r1,|L3.52|
000032  1c40              ADDS     r0,r0,#1
                  |L3.52|
;;;92         for(offset=memtblsize[memx]-1;offset>=0;offset--)//搜索整个内存控制区  
000034  4914              LDR      r1,|L3.136|
000036  3908              SUBS     r1,r1,#8
000038  f8511025          LDR      r1,[r1,r5,LSL #2]
00003c  1e49              SUBS     r1,r1,#1
00003e  d41e              BMI      |L3.126|
;;;93         {     
;;;94     		if(!mallco_dev.memmap[memx][offset])cmemb++;//连续空内存块数增加
000040  eb060685          ADD      r6,r6,r5,LSL #2
000044  6937              LDR      r7,[r6,#0x10]
                  |L3.70|
000046  f837c011          LDRH     r12,[r7,r1,LSL #1]
00004a  f1bc0f00          CMP      r12,#0
00004e  d005              BEQ      |L3.92|
;;;95     		else cmemb=0;								//连续内存块清零
000050  2400              MOVS     r4,#0
                  |L3.82|
;;;96     		if(cmemb==nmemb)							//找到了连续nmemb个空内存块
000052  4284              CMP      r4,r0
000054  d111              BNE      |L3.122|
;;;97     		{
;;;98                 for(i=0;i<nmemb;i++)  					//标注内存块非空 
000056  2200              MOVS     r2,#0
;;;99                 {  
;;;100                    mallco_dev.memmap[memx][offset+i]=nmemb;  
000058  b284              UXTH     r4,r0
00005a  e007              B        |L3.108|
                  |L3.92|
00005c  1c64              ADDS     r4,r4,#1              ;98
00005e  e7f8              B        |L3.82|
                  |L3.96|
000060  6937              LDR      r7,[r6,#0x10]
000062  eb010c02          ADD      r12,r1,r2
000066  1c52              ADDS     r2,r2,#1
000068  f827401c          STRH     r4,[r7,r12,LSL #1]
                  |L3.108|
00006c  4282              CMP      r2,r0                 ;98
00006e  d3f7              BCC      |L3.96|
;;;101                }  
;;;102                return (offset*memblksize[memx]);//返回偏移地址  
000070  f8530025          LDR      r0,[r3,r5,LSL #2]
000074  4348              MULS     r0,r1,r0
                  |L3.118|
;;;103    		}
;;;104        }  
;;;105        return 0XFFFFFFFF;//未找到符合分配条件的内存块  
;;;106    }  
000076  e8bd81f0          POP      {r4-r8,pc}
                  |L3.122|
00007a  1e49              SUBS     r1,r1,#1
00007c  d5e3              BPL      |L3.70|
                  |L3.126|
00007e  4610              MOV      r0,r2                 ;105
000080  e7f9              B        |L3.118|
;;;107    //释放内存(内部调用) 
                          ENDP

000082  0000              DCW      0x0000
                  |L3.132|
                          DCD      ||.data||
                  |L3.136|
                          DCD      ||.constdata||+0x8

                          AREA ||i.my_mem_perused||, CODE, READONLY, ALIGN=2

                  my_mem_perused PROC
;;;67     //返回值:使用率(0~100)
;;;68     u8 my_mem_perused(u8 memx)  
000000  b510              PUSH     {r4,lr}
;;;69     {  
;;;70         u32 used=0;  
;;;71         u32 i;  
;;;72         for(i=0;i<memtblsize[memx];i++)  
000002  4b0b              LDR      r3,|L4.48|
;;;73         {  
;;;74             if(mallco_dev.memmap[memx][i])used++; 
000004  4c0b              LDR      r4,|L4.52|
000006  2200              MOVS     r2,#0                 ;70
000008  f8533020          LDR      r3,[r3,r0,LSL #2]     ;72
00000c  4611              MOV      r1,r2                 ;72
00000e  eb040080          ADD      r0,r4,r0,LSL #2
000012  e005              B        |L4.32|
                  |L4.20|
000014  6904              LDR      r4,[r0,#0x10]
000016  f8344011          LDRH     r4,[r4,r1,LSL #1]
00001a  b104              CBZ      r4,|L4.30|
00001c  1c52              ADDS     r2,r2,#1
                  |L4.30|
00001e  1c49              ADDS     r1,r1,#1
                  |L4.32|
000020  428b              CMP      r3,r1                 ;72
000022  d8f7              BHI      |L4.20|
;;;75         } 
;;;76         return (used*100)/(memtblsize[memx]);  
000024  2064              MOVS     r0,#0x64
000026  4342              MULS     r2,r0,r2
000028  fbb2f0f3          UDIV     r0,r2,r3
00002c  b2c0              UXTB     r0,r0
;;;77     }  
00002e  bd10              POP      {r4,pc}
;;;78     //内存分配(内部调用)
                          ENDP

                  |L4.48|
                          DCD      ||.constdata||
                  |L4.52|
                          DCD      ||.data||

                          AREA ||i.myfree||, CODE, READONLY, ALIGN=2

                  myfree PROC
;;;132    //ptr:内存首地址 
;;;133    void myfree(u8 memx,void *ptr)  
000000  2900              CMP      r1,#0
;;;134    {  
000002  d006              BEQ      |L5.18|
;;;135    	u32 offset;   
;;;136    	if(ptr==NULL)return;//地址为0.  
;;;137     	offset=(u32)ptr-(u32)mallco_dev.membase[memx];     
000004  4a03              LDR      r2,|L5.20|
000006  eb020280          ADD      r2,r2,r0,LSL #2
00000a  6892              LDR      r2,[r2,#8]
00000c  1a89              SUBS     r1,r1,r2
;;;138        my_mem_free(memx,offset);	//释放内存      
00000e  f7ffbffe          B.W      my_mem_free
                  |L5.18|
;;;139    }  
000012  4770              BX       lr
;;;140    //分配内存(外部调用)
                          ENDP

                  |L5.20|
                          DCD      ||.data||

                          AREA ||i.mymalloc||, CODE, READONLY, ALIGN=2

                  mymalloc PROC
;;;143    //返回值:分配到的内存首地址.
;;;144    void *mymalloc(u8 memx,u32 size)  
000000  b510              PUSH     {r4,lr}
;;;145    {  
000002  4604              MOV      r4,r0
;;;146        u32 offset;   
;;;147    	offset=my_mem_malloc(memx,size);  	   	 	   
000004  f7fffffe          BL       my_mem_malloc
;;;148        if(offset==0XFFFFFFFF)return NULL;  
000008  1c41              ADDS     r1,r0,#1
00000a  d005              BEQ      |L6.24|
;;;149        else return (void*)((u32)mallco_dev.membase[memx]+offset);  
00000c  4903              LDR      r1,|L6.28|
00000e  eb010184          ADD      r1,r1,r4,LSL #2
000012  6889              LDR      r1,[r1,#8]
000014  4408              ADD      r0,r0,r1
;;;150    }  
000016  bd10              POP      {r4,pc}
                  |L6.24|
000018  2000              MOVS     r0,#0                 ;148
00001a  bd10              POP      {r4,pc}
;;;151    //重新分配内存(外部调用)
                          ENDP

                  |L6.28|
                          DCD      ||.data||

                          AREA ||i.mymemcpy||, CODE, READONLY, ALIGN=1

                  mymemcpy PROC
;;;41     //n:需要复制的内存长度(字节为单位)
;;;42     void mymemcpy(void *des,void *src,u32 n)  
000000  e003              B        |L7.10|
                  |L7.2|
;;;43     {  
;;;44         u8 *xdes=des;
;;;45     	u8 *xsrc=src; 
;;;46         while(n--)*xdes++=*xsrc++;  
000002  f8113b01          LDRB     r3,[r1],#1
000006  f8003b01          STRB     r3,[r0],#1
                  |L7.10|
00000a  1e52              SUBS     r2,r2,#1
00000c  d2f9              BCS      |L7.2|
;;;47     }  
00000e  4770              BX       lr
;;;48     //设置内存
                          ENDP


                          AREA ||i.mymemset||, CODE, READONLY, ALIGN=1

                  mymemset PROC
;;;51     //count:需要设置的内存大小(字节为单位)
;;;52     void mymemset(void *s,u8 c,u32 count)  
000000  e001              B        |L8.6|
                  |L8.2|
;;;53     {  
;;;54         u8 *xs = s;  
;;;55         while(count--)*xs++=c;  
000002  f8001b01          STRB     r1,[r0],#1
                  |L8.6|
000006  1e52              SUBS     r2,r2,#1
000008  d2fb              BCS      |L8.2|
;;;56     }	   
00000a  4770              BX       lr
;;;57     //内存管理初始化  
                          ENDP


                          AREA ||i.myrealloc||, CODE, READONLY, ALIGN=2

                  myrealloc PROC
;;;155    //返回值:新分配到的内存首地址.
;;;156    void *myrealloc(u8 memx,void *ptr,u32 size)  
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;157    {  
000004  4688              MOV      r8,r1
000006  4617              MOV      r7,r2
000008  4606              MOV      r6,r0
;;;158        u32 offset;    
;;;159        offset=my_mem_malloc(memx,size);   	
00000a  4611              MOV      r1,r2
00000c  f7fffffe          BL       my_mem_malloc
000010  4604              MOV      r4,r0
;;;160        if(offset==0XFFFFFFFF)return NULL;     
000012  1c40              ADDS     r0,r0,#1
000014  d00e              BEQ      |L9.52|
;;;161        else  
;;;162        {  									   
;;;163    	    mymemcpy((void*)((u32)mallco_dev.membase[memx]+offset),ptr,size);	//拷贝旧内存内容到新内存   
000016  4808              LDR      r0,|L9.56|
000018  463a              MOV      r2,r7
00001a  eb000586          ADD      r5,r0,r6,LSL #2
00001e  4641              MOV      r1,r8
000020  68a8              LDR      r0,[r5,#8]
000022  4420              ADD      r0,r0,r4
000024  f7fffffe          BL       mymemcpy
;;;164            myfree(memx,ptr);  											  		//释放旧内存
000028  4641              MOV      r1,r8
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       myfree
;;;165            return (void*)((u32)mallco_dev.membase[memx]+offset);  				//返回新内存首地址
000030  68a8              LDR      r0,[r5,#8]
000032  4420              ADD      r0,r0,r4
                  |L9.52|
;;;166        }  
;;;167    }
000034  e8bd81f0          POP      {r4-r8,pc}
;;;168    
                          ENDP

                  |L9.56|
                          DCD      ||.data||

                          AREA ||.ARM.__AT_0x68000000||, DATA, NOINIT, ALIGN=5

                  mem2base
                          %        983040

                          AREA ||.ARM.__AT_0x680F0000||, DATA, NOINIT, ALIGN=1

                  mem2mapbase
                          %        61440

                          AREA ||.bss||, DATA, NOINIT, ALIGN=5

                  mem1base
                          %        20480

                          AREA ||area_number.14||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.14||, ||.bss||
                  mem1mapbase
                          %        1280

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  memtblsize
                          DCD      0x00000280
                          DCD      0x00007800
                  memblksize
                          DCD      0x00000020
                          DCD      0x00000020
                  memsize
                          DCD      0x00005000
                          DCD      0x000f0000

                          AREA ||.data||, DATA, ALIGN=2

                  mallco_dev
                          DCD      my_mem_init
                          DCD      my_mem_perused
                          DCD      mem1base
                          DCD      mem2base
                          DCD      mem1mapbase
                          DCD      mem2mapbase
000018  00000000          DCB      0x00,0x00,0x00,0x00
