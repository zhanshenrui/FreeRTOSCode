; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\obj\usart.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\usart.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\USER -I..\CORE -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\HARDWARE\LED -I..\HARDWARE\TIMER -I..\HARDWARE\LCD -I..\HARDWARE\EXTI -I..\HARDWARE\KEY -I..\HARDWARE\BEEP -I"E:\STM32F103战舰V3资料\STM32F103 FreeRTOS例程\FreeRTOS实验17-1 FreeRTOS内存管理实验\USER\RTE" -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\usart.crf ..\SYSTEM\usart\usart.c]
                          THUMB

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;131    
;;;132    void USART1_IRQHandler(void)                	//串口1中断服务程序
000000  b570              PUSH     {r4-r6,lr}
;;;133    {
;;;134    	u8 Res;
;;;135    	
;;;136    	if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)  //接收中断(接收到的数据必须是0x0d 0x0a结尾)
000002  4c15              LDR      r4,|L1.88|
000004  f2405125          MOV      r1,#0x525
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       USART_GetITStatus
00000e  2800              CMP      r0,#0
000010  d00e              BEQ      |L1.48|
;;;137    	{
;;;138    		Res =USART_ReceiveData(USART1);	//读取接收到的数据
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       USART_ReceiveData
;;;139    		
;;;140    		if((USART_RX_STA&0x8000)==0)//接收未完成
000018  4a10              LDR      r2,|L1.92|
00001a  b2c1              UXTB     r1,r0                 ;138
00001c  8810              LDRH     r0,[r2,#0]  ; USART_RX_STA
00001e  0403              LSLS     r3,r0,#16
000020  d406              BMI      |L1.48|
;;;141    			{
;;;142    			if(USART_RX_STA&0x4000)//接收到了0x0d
000022  0444              LSLS     r4,r0,#17
000024  f04f0300          MOV      r3,#0
000028  d506              BPL      |L1.56|
;;;143    				{
;;;144    				if(Res!=0x0a)USART_RX_STA=0;//接收错误,重新开始
00002a  290a              CMP      r1,#0xa
00002c  d001              BEQ      |L1.50|
                  |L1.46|
00002e  8013              STRH     r3,[r2,#0]
                  |L1.48|
;;;145    				else USART_RX_STA|=0x8000;	//接收完成了 
;;;146    				}
;;;147    			else //还没收到0X0D
;;;148    				{	
;;;149    				if(Res==0x0d)USART_RX_STA|=0x4000;
;;;150    				else
;;;151    					{
;;;152    					USART_RX_BUF[USART_RX_STA&0X3FFF]=Res ;
;;;153    					USART_RX_STA++;
;;;154    					if(USART_RX_STA>(USART_REC_LEN-1))USART_RX_STA=0;//接收数据错误,重新开始接收	  
;;;155    					}		 
;;;156    				}
;;;157    			}   		 
;;;158         } 
;;;159    } 
000030  bd70              POP      {r4-r6,pc}
                  |L1.50|
000032  f4404000          ORR      r0,r0,#0x8000         ;145
000036  e00d              B        |L1.84|
                  |L1.56|
000038  290d              CMP      r1,#0xd               ;149
00003a  d009              BEQ      |L1.80|
00003c  f3c0040d          UBFX     r4,r0,#0,#14          ;152
000040  4d07              LDR      r5,|L1.96|
000042  1c40              ADDS     r0,r0,#1              ;152
000044  b280              UXTH     r0,r0                 ;153
000046  5529              STRB     r1,[r5,r4]            ;152
000048  8010              STRH     r0,[r2,#0]            ;153
00004a  28c7              CMP      r0,#0xc7              ;154
00004c  d8ef              BHI      |L1.46|
00004e  bd70              POP      {r4-r6,pc}
                  |L1.80|
000050  f4404080          ORR      r0,r0,#0x4000         ;149
                  |L1.84|
000054  8010              STRH     r0,[r2,#0]            ;145
000056  bd70              POP      {r4-r6,pc}
;;;160    #endif	
                          ENDP

                  |L1.88|
                          DCD      0x40013800
                  |L1.92|
                          DCD      ||.data||
                  |L1.96|
                          DCD      ||.bss||

                          AREA ||i._sys_exit||, CODE, READONLY, ALIGN=1

                  _sys_exit PROC
;;;50     //定义_sys_exit()以避免使用半主机模式    
;;;51     void _sys_exit(int x) 
000000  4770              BX       lr
;;;52     { 
;;;53     	x = x; 
;;;54     } 
;;;55     //重定义fputc函数 
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;55     //重定义fputc函数 
;;;56     int fputc(int ch, FILE *f)
000000  4904              LDR      r1,|L3.20|
                  |L3.2|
;;;57     {      
;;;58     	while((USART1->SR&0X40)==0);//循环发送,直到发送完毕   
000002  880a              LDRH     r2,[r1,#0]
000004  0652              LSLS     r2,r2,#25
000006  d5fc              BPL      |L3.2|
;;;59         USART1->DR = (u8) ch;      
000008  4a02              LDR      r2,|L3.20|
00000a  b2c1              UXTB     r1,r0
00000c  1d12              ADDS     r2,r2,#4
00000e  8011              STRH     r1,[r2,#0]
;;;60     	return ch;
;;;61     }
000010  4770              BX       lr
;;;62     #endif 
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40013800

                          AREA ||i.uart_init||, CODE, READONLY, ALIGN=2

                  uart_init PROC
;;;91       
;;;92     void uart_init(u32 bound){
000000  b530              PUSH     {r4,r5,lr}
000002  4605              MOV      r5,r0
000004  b087              SUB      sp,sp,#0x1c
;;;93     	//GPIO端口设置
;;;94     	GPIO_InitTypeDef GPIO_InitStructure;
;;;95     	USART_InitTypeDef USART_InitStructure;
;;;96     	NVIC_InitTypeDef NVIC_InitStructure;
;;;97     	 
;;;98     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA, ENABLE);	//使能USART1，GPIOA时钟
000006  2101              MOVS     r1,#1
000008  f2440004          MOV      r0,#0x4004
00000c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;99       
;;;100    	//USART1_TX   GPIOA.9
;;;101    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //PA.9
000010  f44f7000          MOV      r0,#0x200
000014  f8ad0010          STRH     r0,[sp,#0x10]
;;;102    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000018  2003              MOVS     r0,#3
00001a  f88d0012          STRB     r0,[sp,#0x12]
;;;103    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	//复用推挽输出
00001e  2018              MOVS     r0,#0x18
;;;104    	GPIO_Init(GPIOA, &GPIO_InitStructure);//初始化GPIOA.9
000020  4c1e              LDR      r4,|L4.156|
000022  f88d0013          STRB     r0,[sp,#0x13]         ;103
000026  a904              ADD      r1,sp,#0x10
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       GPIO_Init
;;;105       
;;;106    	//USART1_RX	  GPIOA.10初始化
;;;107    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;//PA10
00002e  1521              ASRS     r1,r4,#20
000030  f8ad1010          STRH     r1,[sp,#0x10]
;;;108    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入
000034  2004              MOVS     r0,#4
000036  f88d0013          STRB     r0,[sp,#0x13]
;;;109    	GPIO_Init(GPIOA, &GPIO_InitStructure);//初始化GPIOA.10  
00003a  a904              ADD      r1,sp,#0x10
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       GPIO_Init
;;;110    
;;;111    	//Usart1 NVIC 配置
;;;112    	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
000042  2025              MOVS     r0,#0x25
000044  f88d0014          STRB     r0,[sp,#0x14]
;;;113    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=7 ;//抢占优先级7
000048  2007              MOVS     r0,#7
00004a  f88d0015          STRB     r0,[sp,#0x15]
;;;114    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;		//子优先级0
00004e  2400              MOVS     r4,#0
000050  f88d4016          STRB     r4,[sp,#0x16]
;;;115    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//IRQ通道使能
000054  2001              MOVS     r0,#1
000056  f88d0017          STRB     r0,[sp,#0x17]
;;;116    	NVIC_Init(&NVIC_InitStructure);	//根据指定的参数初始化VIC寄存器
00005a  a805              ADD      r0,sp,#0x14
00005c  f7fffffe          BL       NVIC_Init
;;;117      
;;;118    	//USART 初始化设置
;;;119    
;;;120    	USART_InitStructure.USART_BaudRate = bound;//串口波特率
;;;121    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式
000060  f8ad4004          STRH     r4,[sp,#4]
;;;122    	USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位
000064  f8ad4006          STRH     r4,[sp,#6]
;;;123    	USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位
000068  f8ad4008          STRH     r4,[sp,#8]
;;;124    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制
00006c  f8ad400c          STRH     r4,[sp,#0xc]
;;;125    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	//收发模式
000070  200c              MOVS     r0,#0xc
;;;126    
;;;127    	USART_Init(USART1, &USART_InitStructure); //初始化串口1
000072  4c0b              LDR      r4,|L4.160|
000074  f8ad000a          STRH     r0,[sp,#0xa]          ;125
000078  9500              STR      r5,[sp,#0]            ;121
00007a  4669              MOV      r1,sp
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       USART_Init
;;;128    	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启串口接受中断
000082  2201              MOVS     r2,#1
000084  f2405125          MOV      r1,#0x525
000088  4620              MOV      r0,r4
00008a  f7fffffe          BL       USART_ITConfig
;;;129    	USART_Cmd(USART1, ENABLE);                    //使能串口1 
00008e  2101              MOVS     r1,#1
000090  4620              MOV      r0,r4
000092  f7fffffe          BL       USART_Cmd
;;;130    }
000096  b007              ADD      sp,sp,#0x1c
000098  bd30              POP      {r4,r5,pc}
;;;131    
                          ENDP

00009a  0000              DCW      0x0000
                  |L4.156|
                          DCD      0x40010800
                  |L4.160|
                          DCD      0x40013800

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  USART_RX_BUF
                          %        200

                          AREA ||.data||, DATA, ALIGN=1

                  USART_RX_STA
000000  0000              DCW      0x0000

                          AREA ||area_number.9||, DATA, ALIGN=2

                          EXPORTAS ||area_number.9||, ||.data||
                  __stdout
                          DCD      0x00000000
