; generated by Component: ARM Compiler 5.06 update 2 (build 183) Tool: ArmCC [4d35cd]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o..\obj\stm32f10x_fsmc.o --asm_dir=..\OBJ\ --list_dir=..\OBJ\ --depend=..\obj\stm32f10x_fsmc.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\USER -I..\CORE -I..\STM32F10x_FWLib\inc -I..\SYSTEM\delay -I..\SYSTEM\sys -I..\SYSTEM\usart -I..\MALLOC -I..\FreeRTOS\include -I..\FreeRTOS\portable\RVDS\ARM_CM3 -I..\HARDWARE\LED -I..\HARDWARE\TIMER -I..\HARDWARE\LCD -I..\HARDWARE\EXTI -I..\HARDWARE\KEY -I..\HARDWARE\BEEP -I"E:\STM32F103战舰V3资料\STM32F103 FreeRTOS例程\FreeRTOS实验17-1 FreeRTOS内存管理实验\USER\RTE" -ID:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -ID:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=520 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\stm32f10x_fsmc.crf ..\STM32F10x_FWLib\src\stm32f10x_fsmc.c]
                          THUMB

                          AREA ||i.FSMC_ClearFlag||, CODE, READONLY, ALIGN=1

                  FSMC_ClearFlag PROC
;;;746      */
;;;747    void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
000000  f04f4220          MOV      r2,#0xa0000000
;;;748    {
;;;749     /* Check the parameters */
;;;750      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;751      assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
;;;752        
;;;753      if(FSMC_Bank == FSMC_Bank2_NAND)
000004  2810              CMP      r0,#0x10
000006  d007              BEQ      |L1.24|
;;;754      {
;;;755        FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
;;;756      }  
;;;757      else if(FSMC_Bank == FSMC_Bank3_NAND)
000008  f5b07f80          CMP      r0,#0x100
00000c  d008              BEQ      |L1.32|
;;;758      {
;;;759        FSMC_Bank3->SR3 &= ~FSMC_FLAG;
;;;760      }
;;;761      /* FSMC_Bank4_PCCARD*/
;;;762      else
;;;763      {
;;;764        FSMC_Bank4->SR4 &= ~FSMC_FLAG;
00000e  f8520fa4          LDR      r0,[r2,#0xa4]!
                  |L1.18|
000012  4388              BICS     r0,r0,r1
000014  6010              STR      r0,[r2,#0]
;;;765      }
;;;766    }
000016  4770              BX       lr
                  |L1.24|
000018  6e50              LDR      r0,[r2,#0x64]         ;755
00001a  4388              BICS     r0,r0,r1              ;755
00001c  6650              STR      r0,[r2,#0x64]         ;755
00001e  4770              BX       lr
                  |L1.32|
000020  f8520f84          LDR      r0,[r2,#0x84]!        ;759
000024  e7f5              B        |L1.18|
;;;767    
                          ENDP


                          AREA ||i.FSMC_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  FSMC_ClearITPendingBit PROC
;;;832      */
;;;833    void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT)
000000  f04f4220          MOV      r2,#0xa0000000
;;;834    {
;;;835      /* Check the parameters */
;;;836      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;837      assert_param(IS_FSMC_IT(FSMC_IT));
;;;838        
;;;839      if(FSMC_Bank == FSMC_Bank2_NAND)
000004  2810              CMP      r0,#0x10
000006  d008              BEQ      |L2.26|
;;;840      {
;;;841        FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
;;;842      }  
;;;843      else if(FSMC_Bank == FSMC_Bank3_NAND)
000008  f5b07f80          CMP      r0,#0x100
00000c  d00a              BEQ      |L2.36|
;;;844      {
;;;845        FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
;;;846      }
;;;847      /* FSMC_Bank4_PCCARD*/
;;;848      else
;;;849      {
;;;850        FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
00000e  f8520fa4          LDR      r0,[r2,#0xa4]!
                  |L2.18|
000012  ea2000d1          BIC      r0,r0,r1,LSR #3
000016  6010              STR      r0,[r2,#0]
;;;851      }
;;;852    }
000018  4770              BX       lr
                  |L2.26|
00001a  6e50              LDR      r0,[r2,#0x64]         ;841
00001c  ea2000d1          BIC      r0,r0,r1,LSR #3       ;841
000020  6650              STR      r0,[r2,#0x64]         ;841
000022  4770              BX       lr
                  |L2.36|
000024  f8520f84          LDR      r0,[r2,#0x84]!        ;845
000028  e7f3              B        |L2.18|
;;;853    
                          ENDP


                          AREA ||i.FSMC_GetECC||, CODE, READONLY, ALIGN=1

                  FSMC_GetECC PROC
;;;602      */
;;;603    uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
000000  f04f4120          MOV      r1,#0xa0000000
;;;604    {
;;;605      uint32_t eccval = 0x00000000;
;;;606      
;;;607      if(FSMC_Bank == FSMC_Bank2_NAND)
000004  2810              CMP      r0,#0x10
000006  d002              BEQ      |L3.14|
;;;608      {
;;;609        /* Get the ECCR2 register value */
;;;610        eccval = FSMC_Bank2->ECCR2;
;;;611      }
;;;612      else
;;;613      {
;;;614        /* Get the ECCR3 register value */
;;;615        eccval = FSMC_Bank3->ECCR3;
000008  f8d10094          LDR      r0,[r1,#0x94]
;;;616      }
;;;617      /* Return the error correction code value */
;;;618      return(eccval);
;;;619    }
00000c  4770              BX       lr
                  |L3.14|
00000e  6f48              LDR      r0,[r1,#0x74]         ;610
000010  4770              BX       lr
;;;620    
                          ENDP


                          AREA ||i.FSMC_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  FSMC_GetFlagStatus PROC
;;;696      */
;;;697    FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
000000  4603              MOV      r3,r0
;;;698    {
;;;699      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;700      uint32_t tmpsr = 0x00000000;
;;;701      
;;;702      /* Check the parameters */
;;;703      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;704      assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
;;;705      
;;;706      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;707      {
;;;708        tmpsr = FSMC_Bank2->SR2;
000004  f04f4220          MOV      r2,#0xa0000000
000008  2b10              CMP      r3,#0x10              ;706
00000a  d008              BEQ      |L4.30|
;;;709      }  
;;;710      else if(FSMC_Bank == FSMC_Bank3_NAND)
00000c  f5b37f80          CMP      r3,#0x100
000010  d007              BEQ      |L4.34|
;;;711      {
;;;712        tmpsr = FSMC_Bank3->SR3;
;;;713      }
;;;714      /* FSMC_Bank4_PCCARD*/
;;;715      else
;;;716      {
;;;717        tmpsr = FSMC_Bank4->SR4;
000012  f8d220a4          LDR      r2,[r2,#0xa4]
                  |L4.22|
;;;718      } 
;;;719      
;;;720      /* Get the flag status */
;;;721      if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )
000016  420a              TST      r2,r1
000018  d000              BEQ      |L4.28|
;;;722      {
;;;723        bitstatus = SET;
00001a  2001              MOVS     r0,#1
                  |L4.28|
;;;724      }
;;;725      else
;;;726      {
;;;727        bitstatus = RESET;
;;;728      }
;;;729      /* Return the flag status */
;;;730      return bitstatus;
;;;731    }
00001c  4770              BX       lr
                  |L4.30|
00001e  6e52              LDR      r2,[r2,#0x64]         ;708
000020  e7f9              B        |L4.22|
                  |L4.34|
000022  f8d22084          LDR      r2,[r2,#0x84]         ;712
000026  e7f6              B        |L4.22|
;;;732    
                          ENDP


                          AREA ||i.FSMC_GetITStatus||, CODE, READONLY, ALIGN=1

                  FSMC_GetITStatus PROC
;;;781      */
;;;782    ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)
000000  4603              MOV      r3,r0
;;;783    {
;;;784      ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;785      uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
;;;786      
;;;787      /* Check the parameters */
;;;788      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;789      assert_param(IS_FSMC_GET_IT(FSMC_IT));
;;;790      
;;;791      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;792      {
;;;793        tmpsr = FSMC_Bank2->SR2;
000004  f04f4220          MOV      r2,#0xa0000000
000008  2b10              CMP      r3,#0x10              ;791
00000a  d00c              BEQ      |L5.38|
;;;794      }  
;;;795      else if(FSMC_Bank == FSMC_Bank3_NAND)
00000c  f5b37f80          CMP      r3,#0x100
000010  d00b              BEQ      |L5.42|
;;;796      {
;;;797        tmpsr = FSMC_Bank3->SR3;
;;;798      }
;;;799      /* FSMC_Bank4_PCCARD*/
;;;800      else
;;;801      {
;;;802        tmpsr = FSMC_Bank4->SR4;
000012  f8d220a4          LDR      r2,[r2,#0xa4]
                  |L5.22|
;;;803      } 
;;;804      
;;;805      itstatus = tmpsr & FSMC_IT;
000016  420a              TST      r2,r1
;;;806      
;;;807      itenable = tmpsr & (FSMC_IT >> 3);
000018  ea0201d1          AND      r1,r2,r1,LSR #3
;;;808      if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
00001c  d002              BEQ      |L5.36|
00001e  2900              CMP      r1,#0
000020  d000              BEQ      |L5.36|
;;;809      {
;;;810        bitstatus = SET;
000022  2001              MOVS     r0,#1
                  |L5.36|
;;;811      }
;;;812      else
;;;813      {
;;;814        bitstatus = RESET;
;;;815      }
;;;816      return bitstatus; 
;;;817    }
000024  4770              BX       lr
                  |L5.38|
000026  6e52              LDR      r2,[r2,#0x64]         ;793
000028  e7f5              B        |L5.22|
                  |L5.42|
00002a  f8d22084          LDR      r2,[r2,#0x84]         ;797
00002e  e7f2              B        |L5.22|
;;;818    
                          ENDP


                          AREA ||i.FSMC_ITConfig||, CODE, READONLY, ALIGN=1

                  FSMC_ITConfig PROC
;;;636      */
;;;637    void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;638    {
;;;639      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;640      assert_param(IS_FSMC_IT(FSMC_IT));	
;;;641      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;642      
;;;643      if (NewState != DISABLE)
;;;644      {
;;;645        /* Enable the selected FSMC_Bank2 interrupts */
;;;646        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;647        {
;;;648          FSMC_Bank2->SR2 |= FSMC_IT;
;;;649        }
;;;650        /* Enable the selected FSMC_Bank3 interrupts */
;;;651        else if (FSMC_Bank == FSMC_Bank3_NAND)
000002  f44f7480          MOV      r4,#0x100
000006  f04f4320          MOV      r3,#0xa0000000        ;648
00000a  b172              CBZ      r2,|L6.42|
00000c  2810              CMP      r0,#0x10              ;646
00000e  d004              BEQ      |L6.26|
000010  42a0              CMP      r0,r4
000012  d105              BNE      |L6.32|
;;;652        {
;;;653          FSMC_Bank3->SR3 |= FSMC_IT;
000014  f8530f84          LDR      r0,[r3,#0x84]!
000018  e004              B        |L6.36|
                  |L6.26|
00001a  6e58              LDR      r0,[r3,#0x64]         ;648
00001c  4308              ORRS     r0,r0,r1              ;648
00001e  e00d              B        |L6.60|
                  |L6.32|
;;;654        }
;;;655        /* Enable the selected FSMC_Bank4 interrupts */
;;;656        else
;;;657        {
;;;658          FSMC_Bank4->SR4 |= FSMC_IT;    
000020  f8530fa4          LDR      r0,[r3,#0xa4]!
                  |L6.36|
000024  4308              ORRS     r0,r0,r1
                  |L6.38|
000026  6018              STR      r0,[r3,#0]
;;;659        }
;;;660      }
;;;661      else
;;;662      {
;;;663        /* Disable the selected FSMC_Bank2 interrupts */
;;;664        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;665        {
;;;666          
;;;667          FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
;;;668        }
;;;669        /* Disable the selected FSMC_Bank3 interrupts */
;;;670        else if (FSMC_Bank == FSMC_Bank3_NAND)
;;;671        {
;;;672          FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
;;;673        }
;;;674        /* Disable the selected FSMC_Bank4 interrupts */
;;;675        else
;;;676        {
;;;677          FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
;;;678        }
;;;679      }
;;;680    }
000028  bd10              POP      {r4,pc}
                  |L6.42|
00002a  2810              CMP      r0,#0x10              ;664
00002c  d004              BEQ      |L6.56|
00002e  42a0              CMP      r0,r4                 ;670
000030  d106              BNE      |L6.64|
000032  f8530f84          LDR      r0,[r3,#0x84]!        ;672
000036  e005              B        |L6.68|
                  |L6.56|
000038  6e58              LDR      r0,[r3,#0x64]         ;667
00003a  4388              BICS     r0,r0,r1              ;667
                  |L6.60|
00003c  6658              STR      r0,[r3,#0x64]         ;648
00003e  bd10              POP      {r4,pc}
                  |L6.64|
000040  f8530fa4          LDR      r0,[r3,#0xa4]!        ;677
                  |L6.68|
000044  4388              BICS     r0,r0,r1              ;672
000046  e7ee              B        |L6.38|
;;;681    
                          ENDP


                          AREA ||i.FSMC_NANDCmd||, CODE, READONLY, ALIGN=2

                  FSMC_NANDCmd PROC
;;;500      */
;;;501    void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000000  f04f4220          MOV      r2,#0xa0000000
;;;502    {
000004  b151              CBZ      r1,|L7.28|
;;;503      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;504      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;505      
;;;506      if (NewState != DISABLE)
;;;507      {
;;;508        /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
;;;509        if(FSMC_Bank == FSMC_Bank2_NAND)
000006  2810              CMP      r0,#0x10
000008  d004              BEQ      |L7.20|
;;;510        {
;;;511          FSMC_Bank2->PCR2 |= PCR_PBKEN_Set;
;;;512        }
;;;513        else
;;;514        {
;;;515          FSMC_Bank3->PCR3 |= PCR_PBKEN_Set;
00000a  f8520f80          LDR      r0,[r2,#0x80]!
00000e  f0400004          ORR      r0,r0,#4
000012  e009              B        |L7.40|
                  |L7.20|
000014  6e10              LDR      r0,[r2,#0x60]         ;511
000016  f0400004          ORR      r0,r0,#4              ;511
00001a  e009              B        |L7.48|
                  |L7.28|
;;;516        }
;;;517      }
;;;518      else
;;;519      {
;;;520        /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
;;;521        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;522        {
;;;523          FSMC_Bank2->PCR2 &= PCR_PBKEN_Reset;
00001c  4905              LDR      r1,|L7.52|
00001e  2810              CMP      r0,#0x10              ;521
000020  d004              BEQ      |L7.44|
;;;524        }
;;;525        else
;;;526        {
;;;527          FSMC_Bank3->PCR3 &= PCR_PBKEN_Reset;
000022  f8520f80          LDR      r0,[r2,#0x80]!
000026  4008              ANDS     r0,r0,r1
                  |L7.40|
000028  6010              STR      r0,[r2,#0]            ;515
;;;528        }
;;;529      }
;;;530    }
00002a  4770              BX       lr
                  |L7.44|
00002c  6e10              LDR      r0,[r2,#0x60]         ;523
00002e  4008              ANDS     r0,r0,r1              ;523
                  |L7.48|
000030  6610              STR      r0,[r2,#0x60]         ;511
000032  4770              BX       lr
;;;531    
                          ENDP

                  |L7.52|
                          DCD      0x000ffffb

                          AREA ||i.FSMC_NANDDeInit||, CODE, READONLY, ALIGN=1

                  FSMC_NANDDeInit PROC
;;;128      */
;;;129    void FSMC_NANDDeInit(uint32_t FSMC_Bank)
000000  b510              PUSH     {r4,lr}
;;;130    {
;;;131      /* Check the parameter */
;;;132      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;133      
;;;134      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;135      {
;;;136        /* Set the FSMC_Bank2 registers to their reset values */
;;;137        FSMC_Bank2->PCR2 = 0x00000018;
000002  2318              MOVS     r3,#0x18
;;;138        FSMC_Bank2->SR2 = 0x00000040;
000004  2440              MOVS     r4,#0x40
000006  f04f4120          MOV      r1,#0xa0000000        ;137
;;;139        FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
00000a  f04f32fc          MOV      r2,#0xfcfcfcfc
00000e  2810              CMP      r0,#0x10              ;134
000010  d005              BEQ      |L8.30|
;;;140        FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
;;;141      }
;;;142      /* FSMC_Bank3_NAND */  
;;;143      else
;;;144      {
;;;145        /* Set the FSMC_Bank3 registers to their reset values */
;;;146        FSMC_Bank3->PCR3 = 0x00000018;
000012  f8413f80          STR      r3,[r1,#0x80]!
;;;147        FSMC_Bank3->SR3 = 0x00000040;
000016  604c              STR      r4,[r1,#4]
;;;148        FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
000018  608a              STR      r2,[r1,#8]
;;;149        FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
00001a  60ca              STR      r2,[r1,#0xc]
;;;150      }  
;;;151    }
00001c  bd10              POP      {r4,pc}
                  |L8.30|
00001e  660b              STR      r3,[r1,#0x60]         ;137
000020  664c              STR      r4,[r1,#0x64]         ;138
000022  668a              STR      r2,[r1,#0x68]         ;139
000024  66ca              STR      r2,[r1,#0x6c]         ;140
000026  bd10              POP      {r4,pc}
;;;152    
                          ENDP


                          AREA ||i.FSMC_NANDECCCmd||, CODE, READONLY, ALIGN=2

                  FSMC_NANDECCCmd PROC
;;;563      */
;;;564    void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000000  f04f4220          MOV      r2,#0xa0000000
;;;565    {
000004  b151              CBZ      r1,|L9.28|
;;;566      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;567      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;568      
;;;569      if (NewState != DISABLE)
;;;570      {
;;;571        /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
;;;572        if(FSMC_Bank == FSMC_Bank2_NAND)
000006  2810              CMP      r0,#0x10
000008  d004              BEQ      |L9.20|
;;;573        {
;;;574          FSMC_Bank2->PCR2 |= PCR_ECCEN_Set;
;;;575        }
;;;576        else
;;;577        {
;;;578          FSMC_Bank3->PCR3 |= PCR_ECCEN_Set;
00000a  f8520f80          LDR      r0,[r2,#0x80]!
00000e  f0400040          ORR      r0,r0,#0x40
000012  e009              B        |L9.40|
                  |L9.20|
000014  6e10              LDR      r0,[r2,#0x60]         ;574
000016  f0400040          ORR      r0,r0,#0x40           ;574
00001a  e009              B        |L9.48|
                  |L9.28|
;;;579        }
;;;580      }
;;;581      else
;;;582      {
;;;583        /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
;;;584        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;585        {
;;;586          FSMC_Bank2->PCR2 &= PCR_ECCEN_Reset;
00001c  4905              LDR      r1,|L9.52|
00001e  2810              CMP      r0,#0x10              ;584
000020  d004              BEQ      |L9.44|
;;;587        }
;;;588        else
;;;589        {
;;;590          FSMC_Bank3->PCR3 &= PCR_ECCEN_Reset;
000022  f8520f80          LDR      r0,[r2,#0x80]!
000026  4008              ANDS     r0,r0,r1
                  |L9.40|
000028  6010              STR      r0,[r2,#0]            ;578
;;;591        }
;;;592      }
;;;593    }
00002a  4770              BX       lr
                  |L9.44|
00002c  6e10              LDR      r0,[r2,#0x60]         ;586
00002e  4008              ANDS     r0,r0,r1              ;586
                  |L9.48|
000030  6610              STR      r0,[r2,#0x60]         ;574
000032  4770              BX       lr
;;;594    
                          ENDP

                  |L9.52|
                          DCD      0x000fffbf

                          AREA ||i.FSMC_NANDInit||, CODE, READONLY, ALIGN=1

                  FSMC_NANDInit PROC
;;;261      */
;;;262    void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;263    {
000002  e9d01201          LDRD     r1,r2,[r0,#4]
;;;264      uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
;;;265        
;;;266      /* Check the parameters */
;;;267      assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));
;;;268      assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));
;;;269      assert_param( IS_FSMC_MEMORY_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));
;;;270      assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));
;;;271      assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));
;;;272      assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));
;;;273      assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));
;;;274      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;275      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;276      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;277      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;278      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;279      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;280      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;281      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;282      
;;;283      /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
;;;284      tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
000006  4311              ORRS     r1,r1,r2
000008  e9d02303          LDRD     r2,r3,[r0,#0xc]
00000c  431a              ORRS     r2,r2,r3
00000e  4311              ORRS     r1,r1,r2
000010  6942              LDR      r2,[r0,#0x14]
000012  ea412142          ORR      r1,r1,r2,LSL #9
000016  6982              LDR      r2,[r0,#0x18]
000018  ea413142          ORR      r1,r1,r2,LSL #13
00001c  f0410408          ORR      r4,r1,#8
;;;285                PCR_MemoryType_NAND |
;;;286                FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
;;;287                FSMC_NANDInitStruct->FSMC_ECC |
;;;288                FSMC_NANDInitStruct->FSMC_ECCPageSize |
;;;289                (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
;;;290                (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
;;;291                
;;;292      /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
;;;293      tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
000020  69c1              LDR      r1,[r0,#0x1c]
000022  e9d12300          LDRD     r2,r3,[r1,#0]
000026  ea422203          ORR      r2,r2,r3,LSL #8
00002a  890b              LDRH     r3,[r1,#8]
00002c  7b09              LDRB     r1,[r1,#0xc]
00002e  041b              LSLS     r3,r3,#16
000030  ea436101          ORR      r1,r3,r1,LSL #24
000034  430a              ORRS     r2,r2,r1
;;;294                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;295                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;296                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;297                
;;;298      /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;299      tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
000036  6a01              LDR      r1,[r0,#0x20]
000038  e9d13500          LDRD     r3,r5,[r1,#0]
00003c  ea432305          ORR      r3,r3,r5,LSL #8
000040  890d              LDRH     r5,[r1,#8]
000042  7b09              LDRB     r1,[r1,#0xc]
000044  042d              LSLS     r5,r5,#16
000046  ea456101          ORR      r1,r5,r1,LSL #24
00004a  430b              ORRS     r3,r3,r1
;;;300                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;301                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;302                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
;;;303      
;;;304      if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
;;;305      {
;;;306        /* FSMC_Bank2_NAND registers configuration */
;;;307        FSMC_Bank2->PCR2 = tmppcr;
00004c  6801              LDR      r1,[r0,#0]
00004e  f04f4020          MOV      r0,#0xa0000000
000052  2910              CMP      r1,#0x10              ;304
000054  d004              BEQ      |L10.96|
;;;308        FSMC_Bank2->PMEM2 = tmppmem;
;;;309        FSMC_Bank2->PATT2 = tmppatt;
;;;310      }
;;;311      else
;;;312      {
;;;313        /* FSMC_Bank3_NAND registers configuration */
;;;314        FSMC_Bank3->PCR3 = tmppcr;
000056  f8404f80          STR      r4,[r0,#0x80]!
;;;315        FSMC_Bank3->PMEM3 = tmppmem;
00005a  6082              STR      r2,[r0,#8]
;;;316        FSMC_Bank3->PATT3 = tmppatt;
00005c  60c3              STR      r3,[r0,#0xc]
;;;317      }
;;;318    }
00005e  bd30              POP      {r4,r5,pc}
                  |L10.96|
000060  6604              STR      r4,[r0,#0x60]         ;307
000062  6682              STR      r2,[r0,#0x68]         ;308
000064  66c3              STR      r3,[r0,#0x6c]         ;309
000066  bd30              POP      {r4,r5,pc}
;;;319    
                          ENDP


                          AREA ||i.FSMC_NANDStructInit||, CODE, READONLY, ALIGN=1

                  FSMC_NANDStructInit PROC
;;;417      */
;;;418    void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
000000  2110              MOVS     r1,#0x10
;;;419    { 
;;;420      /* Reset NAND Init structure parameters values */
;;;421      FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
;;;422      FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
000002  6001              STR      r1,[r0,#0]
000004  2100              MOVS     r1,#0
;;;423      FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
000006  6041              STR      r1,[r0,#4]
;;;424      FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
000008  6081              STR      r1,[r0,#8]
;;;425      FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
00000a  60c1              STR      r1,[r0,#0xc]
;;;426      FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
00000c  6101              STR      r1,[r0,#0x10]
;;;427      FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
00000e  6141              STR      r1,[r0,#0x14]
;;;428      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000010  6181              STR      r1,[r0,#0x18]
000012  69c2              LDR      r2,[r0,#0x1c]
000014  21fc              MOVS     r1,#0xfc
;;;429      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000016  6011              STR      r1,[r2,#0]
000018  69c2              LDR      r2,[r0,#0x1c]
;;;430      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00001a  6051              STR      r1,[r2,#4]
00001c  69c2              LDR      r2,[r0,#0x1c]
;;;431      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
00001e  6091              STR      r1,[r2,#8]
000020  69c2              LDR      r2,[r0,#0x1c]
;;;432      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000022  60d1              STR      r1,[r2,#0xc]
000024  6a02              LDR      r2,[r0,#0x20]
;;;433      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000026  6011              STR      r1,[r2,#0]
000028  6a02              LDR      r2,[r0,#0x20]
;;;434      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00002a  6051              STR      r1,[r2,#4]
00002c  6a02              LDR      r2,[r0,#0x20]
;;;435      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
00002e  6091              STR      r1,[r2,#8]
000030  6a00              LDR      r0,[r0,#0x20]
000032  60c1              STR      r1,[r0,#0xc]
;;;436    }
000034  4770              BX       lr
;;;437    
                          ENDP


                          AREA ||i.FSMC_NORSRAMCmd||, CODE, READONLY, ALIGN=2

                  FSMC_NORSRAMCmd PROC
;;;474      */
;;;475    void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000000  0080              LSLS     r0,r0,#2
;;;476    {
;;;477      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;478      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;479      
;;;480      if (NewState != DISABLE)
;;;481      {
;;;482        /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
;;;483        FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_Set;
000002  f1a040c0          SUB      r0,r0,#0x60000000
000006  2900              CMP      r1,#0                 ;480
;;;484      }
;;;485      else
;;;486      {
;;;487        /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
;;;488        FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_Reset;
000008  6801              LDR      r1,[r0,#0]
00000a  d002              BEQ      |L12.18|
00000c  f0410101          ORR      r1,r1,#1              ;483
000010  e001              B        |L12.22|
                  |L12.18|
000012  4a02              LDR      r2,|L12.28|
000014  4011              ANDS     r1,r1,r2
                  |L12.22|
000016  6001              STR      r1,[r0,#0]            ;483
;;;489      }
;;;490    }
000018  4770              BX       lr
;;;491    
                          ENDP

00001a  0000              DCW      0x0000
                  |L12.28|
                          DCD      0x000ffffe

                          AREA ||i.FSMC_NORSRAMDeInit||, CODE, READONLY, ALIGN=1

                  FSMC_NORSRAMDeInit PROC
;;;101      */
;;;102    void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)
000000  0081              LSLS     r1,r0,#2
;;;103    {
;;;104      /* Check the parameter */
;;;105      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;106      
;;;107      /* FSMC_Bank1_NORSRAM1 */
;;;108      if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
;;;109      {
;;;110        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
;;;111      }
;;;112      /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
;;;113      else
;;;114      {   
;;;115        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
000002  f1a141c0          SUB      r1,r1,#0x60000000
000006  b140              CBZ      r0,|L13.26|
000008  f24300d2          MOV      r0,#0x30d2
00000c  6008              STR      r0,[r1,#0]
                  |L13.14|
;;;116      }
;;;117      FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
00000e  f06f4070          MVN      r0,#0xf0000000
000012  6048              STR      r0,[r1,#4]
;;;118      FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
000014  f8c10104          STR      r0,[r1,#0x104]
;;;119    }
000018  4770              BX       lr
                  |L13.26|
00001a  f04f4220          MOV      r2,#0xa0000000        ;110
00001e  f24300db          MOV      r0,#0x30db            ;110
000022  6010              STR      r0,[r2,#0]            ;110
000024  e7f3              B        |L13.14|
;;;120    
                          ENDP


                          AREA ||i.FSMC_NORSRAMInit||, CODE, READONLY, ALIGN=1

                  FSMC_NORSRAMInit PROC
;;;175      */
;;;176    void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
000000  b510              PUSH     {r4,lr}
;;;177    { 
000002  e9d01201          LDRD     r1,r2,[r0,#4]
;;;178      /* Check the parameters */
;;;179      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));
;;;180      assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));
;;;181      assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));
;;;182      assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));
;;;183      assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));
;;;184      assert_param(IS_FSMC_ASYNWAIT(FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait));
;;;185      assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));
;;;186      assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));
;;;187      assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));
;;;188      assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));
;;;189      assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));
;;;190      assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));
;;;191      assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));  
;;;192      assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));
;;;193      assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));
;;;194      assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));
;;;195      assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));
;;;196      assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
;;;197      assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
;;;198      assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
;;;199      
;;;200      /* Bank1 NOR/SRAM control register configuration */ 
;;;201      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
000006  4311              ORRS     r1,r1,r2
000008  e9d02303          LDRD     r2,r3,[r0,#0xc]
00000c  431a              ORRS     r2,r2,r3
00000e  4311              ORRS     r1,r1,r2
000010  6942              LDR      r2,[r0,#0x14]
000012  4311              ORRS     r1,r1,r2
000014  6982              LDR      r2,[r0,#0x18]
000016  4311              ORRS     r1,r1,r2
000018  69c2              LDR      r2,[r0,#0x1c]
00001a  4311              ORRS     r1,r1,r2
00001c  6a02              LDR      r2,[r0,#0x20]
00001e  4311              ORRS     r1,r1,r2
000020  6a42              LDR      r2,[r0,#0x24]
000022  4311              ORRS     r1,r1,r2
000024  6a82              LDR      r2,[r0,#0x28]
000026  4311              ORRS     r1,r1,r2
000028  6ac2              LDR      r2,[r0,#0x2c]
00002a  4311              ORRS     r1,r1,r2
00002c  6b02              LDR      r2,[r0,#0x30]
00002e  4311              ORRS     r1,r1,r2
000030  6802              LDR      r2,[r0,#0]
000032  0092              LSLS     r2,r2,#2
000034  f1a242c0          SUB      r2,r2,#0x60000000
000038  6011              STR      r1,[r2,#0]
;;;202                (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
;;;203                FSMC_NORSRAMInitStruct->FSMC_MemoryType |
;;;204                FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
;;;205                FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
;;;206                FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
;;;207                FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
;;;208                FSMC_NORSRAMInitStruct->FSMC_WrapMode |
;;;209                FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
;;;210                FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
;;;211                FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
;;;212                FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
;;;213                FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
;;;214    
;;;215      if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
00003a  6881              LDR      r1,[r0,#8]
00003c  2908              CMP      r1,#8
00003e  d107              BNE      |L14.80|
;;;216      {
;;;217        FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_Set;
000040  6801              LDR      r1,[r0,#0]
000042  0089              LSLS     r1,r1,#2
000044  f1a141c0          SUB      r1,r1,#0x60000000
000048  680a              LDR      r2,[r1,#0]
00004a  f0420240          ORR      r2,r2,#0x40
00004e  600a              STR      r2,[r1,#0]
                  |L14.80|
;;;218      }
;;;219      
;;;220      /* Bank1 NOR/SRAM timing register configuration */
;;;221      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
000050  6b41              LDR      r1,[r0,#0x34]
000052  e9d12300          LDRD     r2,r3,[r1,#0]
000056  ea421203          ORR      r2,r2,r3,LSL #4
00005a  688b              LDR      r3,[r1,#8]
00005c  898c              LDRH     r4,[r1,#0xc]
00005e  021b              LSLS     r3,r3,#8
000060  ea434304          ORR      r3,r3,r4,LSL #16
000064  431a              ORRS     r2,r2,r3
000066  8a0b              LDRH     r3,[r1,#0x10]
000068  ea425203          ORR      r2,r2,r3,LSL #20
00006c  7d0b              LDRB     r3,[r1,#0x14]
00006e  6989              LDR      r1,[r1,#0x18]
000070  ea426203          ORR      r2,r2,r3,LSL #24
000074  430a              ORRS     r2,r2,r1
000076  6801              LDR      r1,[r0,#0]
000078  0089              LSLS     r1,r1,#2
00007a  f1a141c0          SUB      r1,r1,#0x60000000
00007e  604a              STR      r2,[r1,#4]
;;;222                (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
;;;223                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
;;;224                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;225                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
;;;226                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
;;;227                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
;;;228                 FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
;;;229                
;;;230        
;;;231      /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
;;;232      if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
000080  6ac1              LDR      r1,[r0,#0x2c]
000082  f5b14f80          CMP      r1,#0x4000
000086  d008              BEQ      |L14.154|
;;;233      {
;;;234        assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));
;;;235        assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
;;;236        assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
;;;237        assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
;;;238        assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
;;;239        assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
;;;240        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
;;;241                  (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
;;;242                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
;;;243                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;244                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
;;;245                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
;;;246                   FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
;;;247      }
;;;248      else
;;;249      {
;;;250        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
000088  6800              LDR      r0,[r0,#0]
00008a  f06f4170          MVN      r1,#0xf0000000
00008e  0080              LSLS     r0,r0,#2
000090  f1a040c0          SUB      r0,r0,#0x60000000
000094  f8c01104          STR      r1,[r0,#0x104]
;;;251      }
;;;252    }
000098  bd10              POP      {r4,pc}
                  |L14.154|
00009a  6b81              LDR      r1,[r0,#0x38]         ;240
00009c  e9d12300          LDRD     r2,r3,[r1,#0]         ;240
0000a0  ea421203          ORR      r2,r2,r3,LSL #4       ;240
0000a4  688b              LDR      r3,[r1,#8]            ;240
0000a6  8a0c              LDRH     r4,[r1,#0x10]         ;240
0000a8  021b              LSLS     r3,r3,#8              ;240
0000aa  ea435304          ORR      r3,r3,r4,LSL #20      ;240
0000ae  431a              ORRS     r2,r2,r3              ;240
0000b0  7d0b              LDRB     r3,[r1,#0x14]         ;240
0000b2  6989              LDR      r1,[r1,#0x18]         ;240
0000b4  ea426203          ORR      r2,r2,r3,LSL #24      ;240
0000b8  6800              LDR      r0,[r0,#0]            ;240
0000ba  430a              ORRS     r2,r2,r1              ;240
0000bc  0080              LSLS     r0,r0,#2              ;240
0000be  f1a040c0          SUB      r0,r0,#0x60000000     ;240
0000c2  f8c02104          STR      r2,[r0,#0x104]        ;240
0000c6  bd10              POP      {r4,pc}
;;;253    
                          ENDP


                          AREA ||i.FSMC_NORSRAMStructInit||, CODE, READONLY, ALIGN=1

                  FSMC_NORSRAMStructInit PROC
;;;379      */
;;;380    void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
000000  b510              PUSH     {r4,lr}
;;;381    {  
;;;382      /* Reset NOR/SRAM Init structure parameters values */
;;;383      FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
000002  2100              MOVS     r1,#0
;;;384      FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
000004  2202              MOVS     r2,#2
000006  e9c01200          STRD     r1,r2,[r0,#0]
;;;385      FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
;;;386      FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
00000a  6081              STR      r1,[r0,#8]
;;;387      FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
00000c  60c1              STR      r1,[r0,#0xc]
;;;388      FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
00000e  6101              STR      r1,[r0,#0x10]
;;;389      FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
000010  6141              STR      r1,[r0,#0x14]
;;;390      FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
000012  6181              STR      r1,[r0,#0x18]
;;;391      FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
;;;392      FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
000014  02d2              LSLS     r2,r2,#11
000016  61c1              STR      r1,[r0,#0x1c]
000018  e9c01208          STRD     r1,r2,[r0,#0x20]
;;;393      FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
00001c  0052              LSLS     r2,r2,#1
00001e  e9c0210a          STRD     r2,r1,[r0,#0x28]
;;;394      FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
;;;395      FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
;;;396      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
000022  6301              STR      r1,[r0,#0x30]
000024  6b43              LDR      r3,[r0,#0x34]
000026  220f              MOVS     r2,#0xf
;;;397      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
000028  601a              STR      r2,[r3,#0]
00002a  6b43              LDR      r3,[r0,#0x34]
;;;398      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
00002c  605a              STR      r2,[r3,#4]
00002e  6b44              LDR      r4,[r0,#0x34]
000030  23ff              MOVS     r3,#0xff
;;;399      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
000032  60a3              STR      r3,[r4,#8]
000034  6b44              LDR      r4,[r0,#0x34]
;;;400      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
000036  60e2              STR      r2,[r4,#0xc]
000038  6b44              LDR      r4,[r0,#0x34]
;;;401      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
00003a  6122              STR      r2,[r4,#0x10]
00003c  6b44              LDR      r4,[r0,#0x34]
;;;402      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
00003e  6162              STR      r2,[r4,#0x14]
000040  6b44              LDR      r4,[r0,#0x34]
;;;403      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
000042  61a1              STR      r1,[r4,#0x18]
000044  6b84              LDR      r4,[r0,#0x38]
;;;404      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;
000046  6022              STR      r2,[r4,#0]
000048  6b84              LDR      r4,[r0,#0x38]
;;;405      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;
00004a  6062              STR      r2,[r4,#4]
00004c  6b84              LDR      r4,[r0,#0x38]
;;;406      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
00004e  60a3              STR      r3,[r4,#8]
000050  6b83              LDR      r3,[r0,#0x38]
;;;407      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;
000052  60da              STR      r2,[r3,#0xc]
000054  6b83              LDR      r3,[r0,#0x38]
;;;408      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;
000056  611a              STR      r2,[r3,#0x10]
000058  6b83              LDR      r3,[r0,#0x38]
;;;409      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
00005a  615a              STR      r2,[r3,#0x14]
00005c  6b80              LDR      r0,[r0,#0x38]
00005e  6181              STR      r1,[r0,#0x18]
;;;410    }
000060  bd10              POP      {r4,pc}
;;;411    
                          ENDP


                          AREA ||i.FSMC_PCCARDCmd||, CODE, READONLY, ALIGN=2

                  FSMC_PCCARDCmd PROC
;;;537      */
;;;538    void FSMC_PCCARDCmd(FunctionalState NewState)
000000  f04f4120          MOV      r1,#0xa0000000
;;;539    {
;;;540      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;541      
;;;542      if (NewState != DISABLE)
000004  2800              CMP      r0,#0
;;;543      {
;;;544        /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
;;;545        FSMC_Bank4->PCR4 |= PCR_PBKEN_Set;
;;;546      }
;;;547      else
;;;548      {
;;;549        /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
;;;550        FSMC_Bank4->PCR4 &= PCR_PBKEN_Reset;
000006  f8510fa0          LDR      r0,[r1,#0xa0]!
00000a  d002              BEQ      |L16.18|
00000c  f0400004          ORR      r0,r0,#4              ;545
000010  e001              B        |L16.22|
                  |L16.18|
000012  4a02              LDR      r2,|L16.28|
000014  4010              ANDS     r0,r0,r2
                  |L16.22|
000016  6008              STR      r0,[r1,#0]            ;545
;;;551      }
;;;552    }
000018  4770              BX       lr
;;;553    
                          ENDP

00001a  0000              DCW      0x0000
                  |L16.28|
                          DCD      0x000ffffb

                          AREA ||i.FSMC_PCCARDDeInit||, CODE, READONLY, ALIGN=1

                  FSMC_PCCARDDeInit PROC
;;;157      */
;;;158    void FSMC_PCCARDDeInit(void)
000000  f04f4020          MOV      r0,#0xa0000000
;;;159    {
;;;160      /* Set the FSMC_Bank4 registers to their reset values */
;;;161      FSMC_Bank4->PCR4 = 0x00000018; 
000004  2118              MOVS     r1,#0x18
000006  f8401fa0          STR      r1,[r0,#0xa0]!
;;;162      FSMC_Bank4->SR4 = 0x00000000;	
00000a  2100              MOVS     r1,#0
00000c  6041              STR      r1,[r0,#4]
;;;163      FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
00000e  f04f31fc          MOV      r1,#0xfcfcfcfc
000012  6081              STR      r1,[r0,#8]
;;;164      FSMC_Bank4->PATT4 = 0xFCFCFCFC;
000014  60c1              STR      r1,[r0,#0xc]
;;;165      FSMC_Bank4->PIO4 = 0xFCFCFCFC;
000016  6101              STR      r1,[r0,#0x10]
;;;166    }
000018  4770              BX       lr
;;;167    
                          ENDP


                          AREA ||i.FSMC_PCCARDInit||, CODE, READONLY, ALIGN=1

                  FSMC_PCCARDInit PROC
;;;327      */
;;;328    void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
000000  b510              PUSH     {r4,lr}
;;;329    {
000002  e9d01200          LDRD     r1,r2,[r0,#0]
;;;330      /* Check the parameters */
;;;331      assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));
;;;332      assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));
;;;333      assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));
;;;334     
;;;335      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;336      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;337      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;338      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;339      
;;;340      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;341      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;342      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;343      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;344      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));
;;;345      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
;;;346      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
;;;347      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
;;;348      
;;;349      /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
;;;350      FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
000006  ea412142          ORR      r1,r1,r2,LSL #9
00000a  6882              LDR      r2,[r0,#8]
00000c  2310              MOVS     r3,#0x10
00000e  ea433242          ORR      r2,r3,r2,LSL #13
000012  4311              ORRS     r1,r1,r2
000014  f04f4220          MOV      r2,#0xa0000000
000018  f8421fa0          STR      r1,[r2,#0xa0]!
;;;351                         FSMC_MemoryDataWidth_16b |  
;;;352                         (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
;;;353                         (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
;;;354                
;;;355      /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
;;;356      FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
00001c  68c1              LDR      r1,[r0,#0xc]
00001e  e9d13400          LDRD     r3,r4,[r1,#0]
000022  ea432304          ORR      r3,r3,r4,LSL #8
000026  890c              LDRH     r4,[r1,#8]
000028  7b09              LDRB     r1,[r1,#0xc]
00002a  0424              LSLS     r4,r4,#16
00002c  ea446101          ORR      r1,r4,r1,LSL #24
000030  430b              ORRS     r3,r3,r1
000032  6093              STR      r3,[r2,#8]
;;;357                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;358                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;359                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;360                
;;;361      /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;362      FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
000034  6901              LDR      r1,[r0,#0x10]
000036  e9d13400          LDRD     r3,r4,[r1,#0]
00003a  ea432304          ORR      r3,r3,r4,LSL #8
00003e  890c              LDRH     r4,[r1,#8]
000040  7b09              LDRB     r1,[r1,#0xc]
000042  0424              LSLS     r4,r4,#16
000044  ea446101          ORR      r1,r4,r1,LSL #24
000048  430b              ORRS     r3,r3,r1
00004a  60d3              STR      r3,[r2,#0xc]
;;;363                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;364                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;365                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
;;;366                
;;;367      /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
;;;368      FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
00004c  6940              LDR      r0,[r0,#0x14]
00004e  e9d01300          LDRD     r1,r3,[r0,#0]
000052  ea412103          ORR      r1,r1,r3,LSL #8
000056  8903              LDRH     r3,[r0,#8]
000058  7b00              LDRB     r0,[r0,#0xc]
00005a  041b              LSLS     r3,r3,#16
00005c  ea436000          ORR      r0,r3,r0,LSL #24
000060  4301              ORRS     r1,r1,r0
000062  6111              STR      r1,[r2,#0x10]
;;;369                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;370                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;371                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
;;;372    }
000064  bd10              POP      {r4,pc}
;;;373    
                          ENDP


                          AREA ||i.FSMC_PCCARDStructInit||, CODE, READONLY, ALIGN=1

                  FSMC_PCCARDStructInit PROC
;;;443      */
;;;444    void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
000000  2100              MOVS     r1,#0
;;;445    {
;;;446      /* Reset PCCARD Init structure parameters values */
;;;447      FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
;;;448      FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
000002  6001              STR      r1,[r0,#0]
;;;449      FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
000004  6041              STR      r1,[r0,#4]
;;;450      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000006  6081              STR      r1,[r0,#8]
000008  68c2              LDR      r2,[r0,#0xc]
00000a  21fc              MOVS     r1,#0xfc
;;;451      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00000c  6011              STR      r1,[r2,#0]
00000e  68c2              LDR      r2,[r0,#0xc]
;;;452      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000010  6051              STR      r1,[r2,#4]
000012  68c2              LDR      r2,[r0,#0xc]
;;;453      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000014  6091              STR      r1,[r2,#8]
000016  68c2              LDR      r2,[r0,#0xc]
;;;454      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000018  60d1              STR      r1,[r2,#0xc]
00001a  6902              LDR      r2,[r0,#0x10]
;;;455      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00001c  6011              STR      r1,[r2,#0]
00001e  6902              LDR      r2,[r0,#0x10]
;;;456      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000020  6051              STR      r1,[r2,#4]
000022  6902              LDR      r2,[r0,#0x10]
;;;457      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
000024  6091              STR      r1,[r2,#8]
000026  6902              LDR      r2,[r0,#0x10]
;;;458      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000028  60d1              STR      r1,[r2,#0xc]
00002a  6942              LDR      r2,[r0,#0x14]
;;;459      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00002c  6011              STR      r1,[r2,#0]
00002e  6942              LDR      r2,[r0,#0x14]
;;;460      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000030  6051              STR      r1,[r2,#4]
000032  6942              LDR      r2,[r0,#0x14]
;;;461      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000034  6091              STR      r1,[r2,#8]
000036  6940              LDR      r0,[r0,#0x14]
000038  60c1              STR      r1,[r0,#0xc]
;;;462    }
00003a  4770              BX       lr
;;;463    
                          ENDP

