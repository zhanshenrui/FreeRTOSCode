vTaskStartScheduler();
vTaskDelay(10);

taskENTER_CRITICAL();																				taskEXIT_CRITICAL();
xTaskCreate(start_task,"start_task",TSK_SIZE_256,NULL,TSK_PRIO_1,&StartTask_Handler);				vTaskDelete(StartTask_Handler);
vTaskSuspend(Task1Task_Handler);																	vTaskResume(Task1Task_Handler);

Key_Queue=xQueueCreate(KEYMSG_Q_NUM,sizeof(u8));
err=xQueueSend(Key_Queue, &key, 10);																xQueueReceive(Key_Queue, &getkey, portMAX_DELAY);//没有中断里接收要设置阻塞时间
xQueueSendFromISR(Message_Queue, USART_RX_BUF, &xHigherPriorityTaskWoken);portYIELD_FROM_ISR(xHigherPriorityTaskWoken);		//中断里要调用portYIELD_FROM_ISR来判断是否调度
err=xQueueReceiveFromISR(Message_Queue,buffer,&xTaskWokenByReceive);portYIELD_FROM_ISR(xTaskWokenByReceive);				//中断里要调用portYIELD_FROM_ISR来判断是否调度

BinarySemaphore=xSemaphoreCreateBinary();
xSemaphoreGiveFromISR(BinarySemaphore, &xHigherPriorityTaskWoken);portYIELD_FROM_ISR(xHigherPriorityTaskWoken);				//中断里要调用portYIELD_FROM_ISR来判断是否调度
err=xSemaphoreTake(BinarySemaphore, portMAX_DELAY);																			//没有中断里接收要设置阻塞时间

CountSemaphore=xSemaphoreCreateCounting(255,0);
err=xSemaphoreGive(CountSemaphore);																	xSemaphoreTake(CountSemaphore, portMAX_DELAY);//没有中断里接收要设置阻塞时间
semavalue=uxSemaphoreGetCount(CountSemaphore);